{
  "version": 3,
  "file": "jonsQuest.js",
  "sources": [
    "js/physics/SAT.js",
    "js/utils.js",
    "js/audio/audio.js",
    "js/graphics/graphics.js",
    "js/physics/physics.js",
    "js/engine/gameObject.js",
    "js/engine/gameItem.js",
    "js/engine/hud.js",
    "js/enemy/enemy.js",
    "js/level/level.js",
    "js/level/lvlComplete.js",
    "js/level/startScreen.js",
    "js/level/level1.js",
    "js/level/level2.js",
    "js/level/level3.js",
    "js/engine/game.js",
    "js/hero/hero.js",
    "js/hero/heroGraphics.js",
    "js/hero/heroPhysics.js",
    "js/hero/heroInput.js",
    "js/main.js"
  ],
  "names": [],
  "mappings": "AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;ACr6BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,G;ACzRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,K;ACtJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;ACphBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;ACnKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;ACvHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;AChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;ACpFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,E;ACjIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;AC3VA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;AC9EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;ACrGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;ACzIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,K;AChOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;AChFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;AC5HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;ACvOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;ACpCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;AC9LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,E;ACnMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,G",
  "sourcesContent": [
    "// Version 0.4.1 - Copyright 2014 -  Jim Riecken <jimr@jimr.ca>\n//\n// Released under the MIT License - https://github.com/jriecken/sat-js\n//\n// A simple library for determining intersections of circles and\n// polygons using the Separating Axis Theorem.\n/** @preserve SAT.js - Version 0.4.1 - Copyright 2014 - Jim Riecken <jimr@jimr.ca> - released under the MIT License. https://github.com/jriecken/sat-js */\n\n/*global define: false, module: false*/\n/*jshint shadow:true, sub:true, forin:true, noarg:true, noempty:true, \n  eqeqeq:true, bitwise:true, strict:true, undef:true, \n  curly:true, browser:true */\n\n// Create a UMD wrapper for SAT. Works in:\n//\n//  - Plain browser via global SAT variable\n//  - AMD loader (like require.js)\n//  - Node.js\n//\n// The quoted properties all over the place are used so that the Closure Compiler\n// does not mangle the exposed API in advanced mode.\n/**\n * @param {*} root - The global scope\n * @param {Function} factory - Factory that creates SAT module\n */\n(function(root, factory) {\n    \"use strict\";\n    if(typeof define === 'function' && define['amd']) {\n        define(factory);\n    } else if(typeof exports === 'object') {\n        module['exports'] = factory();\n    } else {\n        root['SAT'] = factory();\n    }\n}(this, function() {\n    \"use strict\";\n\n    var SAT = {};\n\n    //\n    // ## Vector\n    //\n    // Represents a vector in two dimensions with `x` and `y` properties.\n\n\n    // Create a new Vector, optionally passing in the `x` and `y` coordinates. If\n    // a coordinate is not specified, it will be set to `0`\n    /** \n     * @param {?number=} x The x position.\n     * @param {?number=} y The y position.\n     * @constructor\n     */\n    function Vector(x, y) {\n        this['x'] = x || 0;\n        this['y'] = y || 0;\n    }\n    SAT['Vector'] = Vector;\n    // Alias `Vector` as `V`\n    SAT['V'] = Vector;\n\n\n    // Copy the values of another Vector into this one.\n    /**\n     * @param {Vector} other The other Vector.\n     * @return {Vector} This for chaining.\n     */\n    Vector.prototype['copy'] = Vector.prototype.copy = function(other) {\n        this['x'] = other['x'];\n        this['y'] = other['y'];\n        return this;\n    };\n\n    // Create a new vector with the same coordinates as this on.\n    /**\n     * @return {Vector} The new cloned vector\n     */\n    Vector.prototype['clone'] = Vector.prototype.clone = function() {\n        return new Vector(this['x'], this['y']);\n    };\n\n    // Change this vector to be perpendicular to what it was before. (Effectively\n    // roatates it 90 degrees in a clockwise direction)\n    /**\n     * @return {Vector} This for chaining.\n     */\n    Vector.prototype['perp'] = Vector.prototype.perp = function() {\n        var x = this['x'];\n        this['x'] = this['y'];\n        this['y'] = -x;\n        return this;\n    };\n\n    // Rotate this vector (counter-clockwise) by the specified angle (in radians).\n    /**\n     * @param {number} angle The angle to rotate (in radians)\n     * @return {Vector} This for chaining.\n     */\n    Vector.prototype['rotate'] = Vector.prototype.rotate = function(angle) {\n        var x = this['x'];\n        var y = this['y'];\n        this['x'] = x * Math.cos(angle) - y * Math.sin(angle);\n        this['y'] = x * Math.sin(angle) + y * Math.cos(angle);\n        return this;\n    };\n\n    // Reverse this vector.\n    /**\n     * @return {Vector} This for chaining.\n     */\n    Vector.prototype['reverse'] = Vector.prototype.reverse = function() {\n        this['x'] = -this['x'];\n        this['y'] = -this['y'];\n        return this;\n    };\n\n\n    // Normalize this vector.  (make it have length of `1`)\n    /**\n     * @return {Vector} This for chaining.\n     */\n    Vector.prototype['normalize'] = Vector.prototype.normalize = function() {\n        var d = this.len();\n        if(d > 0) {\n            this['x'] = this['x'] / d;\n            this['y'] = this['y'] / d;\n        }\n        return this;\n    };\n\n    // Add another vector to this one.\n    /**\n     * @param {Vector} other The other Vector.\n     * @return {Vector} This for chaining.\n     */\n    Vector.prototype['add'] = Vector.prototype.add = function(other) {\n        this['x'] += other['x'];\n        this['y'] += other['y'];\n        return this;\n    };\n\n    // Subtract another vector from this one.\n    /**\n     * @param {Vector} other The other Vector.\n     * @return {Vector} This for chaiing.\n     */\n    Vector.prototype['sub'] = Vector.prototype.sub = function(other) {\n        this['x'] -= other['x'];\n        this['y'] -= other['y'];\n        return this;\n    };\n\n    // Scale this vector. An independant scaling factor can be provided\n    // for each axis, or a single scaling factor that will scale both `x` and `y`.\n    /**\n     * @param {number} x The scaling factor in the x direction.\n     * @param {?number=} y The scaling factor in the y direction.  If this\n     *   is not specified, the x scaling factor will be used.\n     * @return {Vector} This for chaining.\n     */\n    Vector.prototype['scale'] = Vector.prototype.scale = function(x, y) {\n        this['x'] *= x;\n        this['y'] *= y || x;\n        return this;\n    };\n\n    // Project this vector on to another vector.\n    /**\n     * @param {Vector} other The vector to project onto.\n     * @return {Vector} This for chaining.\n     */\n    Vector.prototype['project'] = Vector.prototype.project = function(other) {\n        var amt = this.dot(other) / other.len2();\n        this['x'] = amt * other['x'];\n        this['y'] = amt * other['y'];\n        return this;\n    };\n\n    // Project this vector onto a vector of unit length. This is slightly more efficient\n    // than `project` when dealing with unit vectors.\n    /**\n     * @param {Vector} other The unit vector to project onto.\n     * @return {Vector} This for chaining.\n     */\n    Vector.prototype['projectN'] = Vector.prototype.projectN = function(other) {\n        var amt = this.dot(other);\n        this['x'] = amt * other['x'];\n        this['y'] = amt * other['y'];\n        return this;\n    };\n\n    // Reflect this vector on an arbitrary axis.\n    /**\n     * @param {Vector} axis The vector representing the axis.\n     * @return {Vector} This for chaining.\n     */\n    Vector.prototype['reflect'] = Vector.prototype.reflect = function(axis) {\n        var x = this['x'];\n        var y = this['y'];\n        this.project(axis).scale(2);\n        this['x'] -= x;\n        this['y'] -= y;\n        return this;\n    };\n\n    // Reflect this vector on an arbitrary axis (represented by a unit vector). This is\n    // slightly more efficient than `reflect` when dealing with an axis that is a unit vector.\n    /**\n     * @param {Vector} axis The unit vector representing the axis.\n     * @return {Vector} This for chaining.\n     */\n    Vector.prototype['reflectN'] = Vector.prototype.reflectN = function(axis) {\n        var x = this['x'];\n        var y = this['y'];\n        this.projectN(axis).scale(2);\n        this['x'] -= x;\n        this['y'] -= y;\n        return this;\n    };\n\n    // Get the dot product of this vector and another.\n    /**\n     * @param {Vector}  other The vector to dot this one against.\n     * @return {number} The dot product.\n     */\n    Vector.prototype['dot'] = Vector.prototype.dot = function(other) {\n        return this['x'] * other['x'] + this['y'] * other['y'];\n    };\n\n    // Get the squared length of this vector.\n    /**\n     * @return {number} The length^2 of this vector.\n     */\n    Vector.prototype['len2'] = Vector.prototype.len2 = function() {\n        return this.dot(this);\n    };\n\n    // Get the length of this vector.\n    /**\n     * @return {number} The length of this vector.\n     */\n    Vector.prototype['len'] = Vector.prototype.len = function() {\n        return Math.sqrt(this.len2());\n    };\n\n    // ## Circle\n    //\n    // Represents a circle with a position and a radius.\n\n    // Create a new circle, optionally passing in a position and/or radius. If no position\n    // is given, the circle will be at `(0,0)`. If no radius is provided, the circle will\n    // have a radius of `0`.\n    /**\n     * @param {Vector=} pos A vector representing the position of the center of the circle\n     * @param {?number=} r The radius of the circle\n     * @constructor\n     */\n    function Circle(pos, r) {\n        this['pos'] = pos || new Vector();\n        this['r'] = r || 0;\n    }\n    SAT['Circle'] = Circle;\n\n    // ## Polygon\n    //\n    // Represents a *convex* polygon with any number of points (specified in counter-clockwise order)\n    //\n    // Note: If you manually change the `points`, `angle`, or `offset` properties, you **must** call `recalc`\n    // afterwards so that the changes get applied correctly.\n\n    // Create a new polygon, passing in a position vector, and an array of points (represented\n    // by vectors relative to the position vector). If no position is passed in, the position\n    // of the polygon will be `(0,0)`.\n    /**\n     * @param {Vector=} pos A vector representing the origin of the polygon. (all other\n     *   points are relative to this one)\n     * @param {Array.<Vector>=} points An array of vectors representing the points in the polygon,\n     *   in counter-clockwise order.\n     * @constructor\n     */\n    function Polygon(pos, points) {\n        this['pos'] = pos || new Vector();\n        this['points'] = points || [];\n        this['angle'] = 0;\n        this['offset'] = new Vector();\n        this.recalc();\n    }\n    SAT['Polygon'] = Polygon;\n\n    // Set the points of the polygon.\n    //\n    // Note: This calls `recalc` for you.\n    /**\n     * @param {Array.<Vector>=} points An array of vectors representing the points in the polygon,\n     *   in counter-clockwise order.\n     * @return {Polygon} This for chaining.\n     */\n    Polygon.prototype['setPoints'] = Polygon.prototype.setPoints = function(points) {\n        this['points'] = points;\n        this.recalc();\n        return this;\n    };\n\n    // Set the current rotation angle of the polygon.\n    //\n    // Note: This calls `recalc` for you.\n    /**\n     * @param {number} angle The current rotation angle (in radians).\n     * @return {Polygon} This for chaining.\n     */\n    Polygon.prototype['setAngle'] = Polygon.prototype.setAngle = function(angle) {\n        this['angle'] = angle;\n        this.recalc();\n        return this;\n    };\n\n    // Set the current offset to apply to the `points` before applying the `angle` rotation.\n    //\n    // Note: This calls `recalc` for you.\n    /**\n     * @param {Vector} offset The new offset vector.\n     * @return {Polygon} This for chaining.\n     */\n    Polygon.prototype['setOffset'] = Polygon.prototype.setOffset = function(offset) {\n        this['offset'] = offset;\n        this.recalc();\n        return this;\n    };\n\n    // Rotates this polygon counter-clockwise around the origin of *its local coordinate system* (i.e. `pos`).\n    //\n    // Note: This changes the **original** points (so any `angle` will be applied on top of this rotation)\n    // Note: This calls `recalc` for you.\n    /**\n     * @param {number} angle The angle to rotate (in radians)\n     * @return {Polygon} This for chaining.\n     */\n    Polygon.prototype['rotate'] = Polygon.prototype.rotate = function(angle) {\n        var points = this['points'];\n        var len = points.length;\n        for(var i = 0; i < len; i++) {\n            points[i].rotate(angle);\n        }\n        this.recalc();\n        return this;\n    };\n\n    // Translates the points of this polygon by a specified amount relative to the origin of *its own coordinate\n    // system* (i.e. `pos`).\n    //\n    // This is most useful to change the \"center point\" of a polygon. If you just want to move the whole polygon, change\n    // the coordinates of `pos`.\n    //\n    // Note: This changes the **original** points (so any `offset` will be applied on top of this translation)\n    // Note: This calls `recalc` for you.\n    /**\n     * @param {number} x The horizontal amount to translate.\n     * @param {number} y The vertical amount to translate.\n     * @return {Polygon} This for chaining.\n     */\n    Polygon.prototype['translate'] = Polygon.prototype.translate = function(x, y) {\n        var points = this['points'];\n        var len = points.length;\n        for(var i = 0; i < len; i++) {\n            points[i].x += x;\n            points[i].y += y;\n        }\n        this.recalc();\n        return this;\n    };\n\n\n    // Computes the calculated collision polygon. Applies the `angle` and `offset` to the original points then recalculates the\n    // edges and normals of the collision polygon.\n    //\n    // This **must** be called if the `points` array, `angle`, or `offset` is modified manualy.\n    /**\n     * @return {Polygon} This for chaining.\n     */\n    Polygon.prototype['recalc'] = Polygon.prototype.recalc = function() {\n        var i;\n        // Calculated points - this is what is used for underlying collisions and takes into account\n        // the angle/offset set on the polygon.\n        var calcPoints = this['calcPoints'] = [];\n        // The edges here are the direction of the `n`th edge of the polygon, relative to\n        // the `n`th point. If you want to draw a given edge from the edge value, you must\n        // first translate to the position of the starting point.\n        var edges = this['edges'] = [];\n        // The normals here are the direction of the normal for the `n`th edge of the polygon, relative\n        // to the position of the `n`th point. If you want to draw an edge normal, you must first\n        // translate to the position of the starting point.\n        var normals = this['normals'] = [];\n        // Copy the original points array and apply the offset/angle\n        var points = this['points'];\n        var offset = this['offset'];\n        var angle = this['angle'];\n        var len = points.length;\n        for(i = 0; i < len; i++) {\n            var calcPoint = points[i].clone();\n            calcPoints.push(calcPoint);\n            calcPoint.x += offset.x;\n            calcPoint.y += offset.y;\n            if(angle !== 0) {\n                calcPoint.rotate(angle);\n            }\n        }\n        // Calculate the edges/normals\n        for(i = 0; i < len; i++) {\n            var p1 = calcPoints[i];\n            var p2 = i < len - 1 ? calcPoints[i + 1] : calcPoints[0];\n            var e = new Vector().copy(p2).sub(p1);\n            var n = new Vector().copy(e).perp().normalize();\n            edges.push(e);\n            normals.push(n);\n        }\n        return this;\n    };\n\n    // ## Box\n    //\n    // Represents an axis-aligned box, with a width and height.\n\n\n    // Create a new box, with the specified position, width, and height. If no position\n    // is given, the position will be `(0,0)`. If no width or height are given, they will\n    // be set to `0`.\n    /**\n     * @param {Vector=} pos A vector representing the top-left of the box.\n     * @param {?number=} w The width of the box.\n     * @param {?number=} h The height of the box.\n     * @constructor\n     */\n    function Box(pos, w, h) {\n        this['pos'] = pos || new Vector();\n        this['w'] = w || 0;\n        this['h'] = h || 0;\n    }\n    SAT['Box'] = Box;\n\n    // Returns a polygon whose edges are the same as this box.\n    /**\n     * @return {Polygon} A new Polygon that represents this box.\n     */\n    Box.prototype['toPolygon'] = Box.prototype.toPolygon = function() {\n        var pos = this['pos'];\n        var w = this['w'];\n        var h = this['h'];\n        return new Polygon(new Vector(pos['x'], pos['y']), [\n         new Vector(), new Vector(w, 0),\n         new Vector(w, h), new Vector(0, h)\n        ]);\n    };\n\n    // ## Response\n    //\n    // An object representing the result of an intersection. Contains:\n    //  - The two objects participating in the intersection\n    //  - The vector representing the minimum change necessary to extract the first object\n    //    from the second one (as well as a unit vector in that direction and the magnitude\n    //    of the overlap)\n    //  - Whether the first object is entirely inside the second, and vice versa.\n    /**\n     * @constructor\n     */\n    function Response() {\n        this['a'] = null;\n        this['b'] = null;\n        this['overlapN'] = new Vector();\n        this['overlapV'] = new Vector();\n        this.clear();\n    }\n    SAT['Response'] = Response;\n\n    // Set some values of the response back to their defaults.  Call this between tests if\n    // you are going to reuse a single Response object for multiple intersection tests (recommented\n    // as it will avoid allcating extra memory)\n    /**\n     * @return {Response} This for chaining\n     */\n    Response.prototype['clear'] = Response.prototype.clear = function() {\n        this['aInB'] = true;\n        this['bInA'] = true;\n        this['overlap'] = Number.MAX_VALUE;\n        return this;\n    };\n\n    // ## Object Pools\n\n    // A pool of `Vector` objects that are used in calculations to avoid\n    // allocating memory.\n    /**\n     * @type {Array.<Vector>}\n     */\n    var T_VECTORS = [];\n    for(var i = 0; i < 10; i++) { T_VECTORS.push(new Vector()); }\n\n    // A pool of arrays of numbers used in calculations to avoid allocating\n    // memory.\n    /**\n     * @type {Array.<Array.<number>>}\n     */\n    var T_ARRAYS = [];\n    for(var i = 0; i < 5; i++) { T_ARRAYS.push([]); }\n\n    // Temporary response used for polygon hit detection.\n    /**\n     * @type {Response}\n     */\n    var T_RESPONSE = new Response();\n\n    // Unit square polygon used for polygon hit detection.\n    /**\n     * @type {Polygon}\n     */\n    var UNIT_SQUARE = new Box(new Vector(), 1, 1).toPolygon();\n\n    // ## Helper Functions\n\n    // Flattens the specified array of points onto a unit vector axis,\n    // resulting in a one dimensional range of the minimum and\n    // maximum value on that axis.\n    /**\n     * @param {Array.<Vector>} points The points to flatten.\n     * @param {Vector} normal The unit vector axis to flatten on.\n     * @param {Array.<number>} result An array.  After calling this function,\n     *   result[0] will be the minimum value,\n     *   result[1] will be the maximum value.\n     */\n    function flattenPointsOn(points, normal, result) {\n        var min = Number.MAX_VALUE;\n        var max = -Number.MAX_VALUE;\n        var len = points.length;\n        for(var i = 0; i < len; i++) {\n            // The magnitude of the projection of the point onto the normal\n            var dot = points[i].dot(normal);\n            if(dot < min) { min = dot; }\n            if(dot > max) { max = dot; }\n        }\n        result[0] = min; result[1] = max;\n    }\n\n    // Check whether two convex polygons are separated by the specified\n    // axis (must be a unit vector).\n    /**\n     * @param {Vector} aPos The position of the first polygon.\n     * @param {Vector} bPos The position of the second polygon.\n     * @param {Array.<Vector>} aPoints The points in the first polygon.\n     * @param {Array.<Vector>} bPoints The points in the second polygon.\n     * @param {Vector} axis The axis (unit sized) to test against.  The points of both polygons\n     *   will be projected onto this axis.\n     * @param {Response=} response A Response object (optional) which will be populated\n     *   if the axis is not a separating axis.\n     * @return {boolean} true if it is a separating axis, false otherwise.  If false,\n     *   and a response is passed in, information about how much overlap and\n     *   the direction of the overlap will be populated.\n     */\n    function isSeparatingAxis(aPos, bPos, aPoints, bPoints, axis, response) {\n        var rangeA = T_ARRAYS.pop();\n        var rangeB = T_ARRAYS.pop();\n        // The magnitude of the offset between the two polygons\n        var offsetV = T_VECTORS.pop().copy(bPos).sub(aPos);\n        var projectedOffset = offsetV.dot(axis);\n        // Project the polygons onto the axis.\n        flattenPointsOn(aPoints, axis, rangeA);\n        flattenPointsOn(bPoints, axis, rangeB);\n        // Move B's range to its position relative to A.\n        rangeB[0] += projectedOffset;\n        rangeB[1] += projectedOffset;\n        // Check if there is a gap. If there is, this is a separating axis and we can stop\n        if(rangeA[0] > rangeB[1] || rangeB[0] > rangeA[1]) {\n            T_VECTORS.push(offsetV);\n            T_ARRAYS.push(rangeA);\n            T_ARRAYS.push(rangeB);\n            return true;\n        }\n        // This is not a separating axis. If we're calculating a response, calculate the overlap.\n        if(response) {\n            var overlap = 0;\n            // A starts further left than B\n            if(rangeA[0] < rangeB[0]) {\n                response['aInB'] = false;\n                // A ends before B does. We have to pull A out of B\n                if(rangeA[1] < rangeB[1]) {\n                    overlap = rangeA[1] - rangeB[0];\n                    response['bInA'] = false;\n                    // B is fully inside A.  Pick the shortest way out.\n                } else {\n                    var option1 = rangeA[1] - rangeB[0];\n                    var option2 = rangeB[1] - rangeA[0];\n                    overlap = option1 < option2 ? option1 : -option2;\n                }\n                // B starts further left than A\n            } else {\n                response['bInA'] = false;\n                // B ends before A ends. We have to push A out of B\n                if(rangeA[1] > rangeB[1]) {\n                    overlap = rangeA[0] - rangeB[1];\n                    response['aInB'] = false;\n                    // A is fully inside B.  Pick the shortest way out.\n                } else {\n                    var option1 = rangeA[1] - rangeB[0];\n                    var option2 = rangeB[1] - rangeA[0];\n                    overlap = option1 < option2 ? option1 : -option2;\n                }\n            }\n            // If this is the smallest amount of overlap we've seen so far, set it as the minimum overlap.\n            var absOverlap = Math.abs(overlap);\n            if(absOverlap < response['overlap']) {\n                response['overlap'] = absOverlap;\n                response['overlapN'].copy(axis);\n                if(overlap < 0) {\n                    response['overlapN'].reverse();\n                }\n            }\n        }\n        T_VECTORS.push(offsetV);\n        T_ARRAYS.push(rangeA);\n        T_ARRAYS.push(rangeB);\n        return false;\n    }\n\n    // Calculates which Vornoi region a point is on a line segment.\n    // It is assumed that both the line and the point are relative to `(0,0)`\n    //\n    //            |       (0)      |\n    //     (-1)  [S]--------------[E]  (1)\n    //            |       (0)      |\n    /**\n     * @param {Vector} line The line segment.\n     * @param {Vector} point The point.\n     * @return  {number} LEFT_VORNOI_REGION (-1) if it is the left region, \n     *          MIDDLE_VORNOI_REGION (0) if it is the middle region, \n     *          RIGHT_VORNOI_REGION (1) if it is the right region.\n     */\n    function vornoiRegion(line, point) {\n        var len2 = line.len2();\n        var dp = point.dot(line);\n        // If the point is beyond the start of the line, it is in the\n        // left vornoi region.\n        if(dp < 0) { return LEFT_VORNOI_REGION; }\n            // If the point is beyond the end of the line, it is in the\n            // right vornoi region.\n        else if(dp > len2) { return RIGHT_VORNOI_REGION; }\n            // Otherwise, it's in the middle one.\n        else { return MIDDLE_VORNOI_REGION; }\n    }\n    // Constants for Vornoi regions\n    /**\n     * @const\n     */\n    var LEFT_VORNOI_REGION = -1;\n    /**\n     * @const\n     */\n    var MIDDLE_VORNOI_REGION = 0;\n    /**\n     * @const\n     */\n    var RIGHT_VORNOI_REGION = 1;\n\n    // ## Collision Tests\n\n    // Check if a point is inside a circle.\n    /**\n     * @param {Vector} p The point to test.\n     * @param {Circle} c The circle to test.\n     * @return {boolean} true if the point is inside the circle, false if it is not.\n     */\n    function pointInCircle(p, c) {\n        var differenceV = T_VECTORS.pop().copy(p).sub(c['pos']);\n        var radiusSq = c['r'] * c['r'];\n        var distanceSq = differenceV.len2();\n        T_VECTORS.push(differenceV);\n        // If the distance between is smaller than the radius then the point is inside the circle.\n        return distanceSq <= radiusSq;\n    }\n    SAT['pointInCircle'] = pointInCircle;\n\n    // Check if a point is inside a convex polygon.\n    /**\n     * @param {Vector} p The point to test.\n     * @param {Polygon} poly The polygon to test.\n     * @return {boolean} true if the point is inside the polygon, false if it is not.\n     */\n    function pointInPolygon(p, poly) {\n        UNIT_SQUARE['pos'].copy(p);\n        T_RESPONSE.clear();\n        var result = testPolygonPolygon(UNIT_SQUARE, poly, T_RESPONSE);\n        if(result) {\n            result = T_RESPONSE['aInB'];\n        }\n        return result;\n    }\n    SAT['pointInPolygon'] = pointInPolygon;\n\n    // Check if two circles collide.\n    /**\n     * @param {Circle} a The first circle.\n     * @param {Circle} b The second circle.\n     * @param {Response=} response Response object (optional) that will be populated if\n     *   the circles intersect.\n     * @return {boolean} true if the circles intersect, false if they don't. \n     */\n    function testCircleCircle(a, b, response) {\n        // Check if the distance between the centers of the two\n        // circles is greater than their combined radius.\n        var differenceV = T_VECTORS.pop().copy(b['pos']).sub(a['pos']);\n        var totalRadius = a['r'] + b['r'];\n        var totalRadiusSq = totalRadius * totalRadius;\n        var distanceSq = differenceV.len2();\n        // If the distance is bigger than the combined radius, they don't intersect.\n        if(distanceSq > totalRadiusSq) {\n            T_VECTORS.push(differenceV);\n            return false;\n        }\n        // They intersect.  If we're calculating a response, calculate the overlap.\n        if(response) {\n            var dist = Math.sqrt(distanceSq);\n            response['a'] = a;\n            response['b'] = b;\n            response['overlap'] = totalRadius - dist;\n            response['overlapN'].copy(differenceV.normalize());\n            response['overlapV'].copy(differenceV).scale(response['overlap']);\n            response['aInB'] = a['r'] <= b['r'] && dist <= b['r'] - a['r'];\n            response['bInA'] = b['r'] <= a['r'] && dist <= a['r'] - b['r'];\n        }\n        T_VECTORS.push(differenceV);\n        return true;\n    }\n    SAT['testCircleCircle'] = testCircleCircle;\n\n    // Check if a polygon and a circle collide.\n    /**\n     * @param {Polygon} polygon The polygon.\n     * @param {Circle} circle The circle.\n     * @param {Response=} response Response object (optional) that will be populated if\n     *   they interset.\n     * @return {boolean} true if they intersect, false if they don't.\n     */\n    function testPolygonCircle(polygon, circle, response) {\n        // Get the position of the circle relative to the polygon.\n        var circlePos = T_VECTORS.pop().copy(circle['pos']).sub(polygon['pos']);\n        var radius = circle['r'];\n        var radius2 = radius * radius;\n        var points = polygon['calcPoints'];\n        var len = points.length;\n        var edge = T_VECTORS.pop();\n        var point = T_VECTORS.pop();\n\n        // For each edge in the polygon:\n        for(var i = 0; i < len; i++) {\n            var next = i === len - 1 ? 0 : i + 1;\n            var prev = i === 0 ? len - 1 : i - 1;\n            var overlap = 0;\n            var overlapN = null;\n\n            // Get the edge.\n            edge.copy(polygon['edges'][i]);\n            // Calculate the center of the circle relative to the starting point of the edge.\n            point.copy(circlePos).sub(points[i]);\n\n            // If the distance between the center of the circle and the point\n            // is bigger than the radius, the polygon is definitely not fully in\n            // the circle.\n            if(response && point.len2() > radius2) {\n                response['aInB'] = false;\n            }\n\n            // Calculate which Vornoi region the center of the circle is in.\n            var region = vornoiRegion(edge, point);\n            // If it's the left region:\n            if(region === LEFT_VORNOI_REGION) {\n                // We need to make sure we're in the RIGHT_VORNOI_REGION of the previous edge.\n                edge.copy(polygon['edges'][prev]);\n                // Calculate the center of the circle relative the starting point of the previous edge\n                var point2 = T_VECTORS.pop().copy(circlePos).sub(points[prev]);\n                region = vornoiRegion(edge, point2);\n                if(region === RIGHT_VORNOI_REGION) {\n                    // It's in the region we want.  Check if the circle intersects the point.\n                    var dist = point.len();\n                    if(dist > radius) {\n                        // No intersection\n                        T_VECTORS.push(circlePos);\n                        T_VECTORS.push(edge);\n                        T_VECTORS.push(point);\n                        T_VECTORS.push(point2);\n                        return false;\n                    } else if(response) {\n                        // It intersects, calculate the overlap.\n                        response['bInA'] = false;\n                        overlapN = point.normalize();\n                        overlap = radius - dist;\n                    }\n                }\n                T_VECTORS.push(point2);\n                // If it's the right region:\n            } else if(region === RIGHT_VORNOI_REGION) {\n                // We need to make sure we're in the left region on the next edge\n                edge.copy(polygon['edges'][next]);\n                // Calculate the center of the circle relative to the starting point of the next edge.\n                point.copy(circlePos).sub(points[next]);\n                region = vornoiRegion(edge, point);\n                if(region === LEFT_VORNOI_REGION) {\n                    // It's in the region we want.  Check if the circle intersects the point.\n                    var dist = point.len();\n                    if(dist > radius) {\n                        // No intersection\n                        T_VECTORS.push(circlePos);\n                        T_VECTORS.push(edge);\n                        T_VECTORS.push(point);\n                        return false;\n                    } else if(response) {\n                        // It intersects, calculate the overlap.\n                        response['bInA'] = false;\n                        overlapN = point.normalize();\n                        overlap = radius - dist;\n                    }\n                }\n                // Otherwise, it's the middle region:\n            } else {\n                // Need to check if the circle is intersecting the edge,\n                // Change the edge into its \"edge normal\".\n                var normal = edge.perp().normalize();\n                // Find the perpendicular distance between the center of the \n                // circle and the edge.\n                var dist = point.dot(normal);\n                var distAbs = Math.abs(dist);\n                // If the circle is on the outside of the edge, there is no intersection.\n                if(dist > 0 && distAbs > radius) {\n                    // No intersection\n                    T_VECTORS.push(circlePos);\n                    T_VECTORS.push(normal);\n                    T_VECTORS.push(point);\n                    return false;\n                } else if(response) {\n                    // It intersects, calculate the overlap.\n                    overlapN = normal;\n                    overlap = radius - dist;\n                    // If the center of the circle is on the outside of the edge, or part of the\n                    // circle is on the outside, the circle is not fully inside the polygon.\n                    if(dist >= 0 || overlap < 2 * radius) {\n                        response['bInA'] = false;\n                    }\n                }\n            }\n\n            // If this is the smallest overlap we've seen, keep it. \n            // (overlapN may be null if the circle was in the wrong Vornoi region).\n            if(overlapN && response && Math.abs(overlap) < Math.abs(response['overlap'])) {\n                response['overlap'] = overlap;\n                response['overlapN'].copy(overlapN);\n            }\n        }\n\n        // Calculate the final overlap vector - based on the smallest overlap.\n        if(response) {\n            response['a'] = polygon;\n            response['b'] = circle;\n            response['overlapV'].copy(response['overlapN']).scale(response['overlap']);\n        }\n        T_VECTORS.push(circlePos);\n        T_VECTORS.push(edge);\n        T_VECTORS.push(point);\n        return true;\n    }\n    SAT['testPolygonCircle'] = testPolygonCircle;\n\n    // Check if a circle and a polygon collide.\n    //\n    // **NOTE:** This is slightly less efficient than polygonCircle as it just\n    // runs polygonCircle and reverses everything at the end.\n    /**\n     * @param {Circle} circle The circle.\n     * @param {Polygon} polygon The polygon.\n     * @param {Response=} response Response object (optional) that will be populated if\n     *   they interset.\n     * @return {boolean} true if they intersect, false if they don't.\n     */\n    function testCirclePolygon(circle, polygon, response) {\n        // Test the polygon against the circle.\n        var result = testPolygonCircle(polygon, circle, response);\n        if(result && response) {\n            // Swap A and B in the response.\n            var a = response['a'];\n            var aInB = response['aInB'];\n            response['overlapN'].reverse();\n            response['overlapV'].reverse();\n            response['a'] = response['b'];\n            response['b'] = a;\n            response['aInB'] = response['bInA'];\n            response['bInA'] = aInB;\n        }\n        return result;\n    }\n    SAT['testCirclePolygon'] = testCirclePolygon;\n\n    // Checks whether polygons collide.\n    /**\n     * @param {Polygon} a The first polygon.\n     * @param {Polygon} b The second polygon.\n     * @param {Response=} response Response object (optional) that will be populated if\n     *   they interset.\n     * @return {boolean} true if they intersect, false if they don't.\n     */\n    function testPolygonPolygon(a, b, response) {\n        var aPoints = a['calcPoints'];\n        var aLen = aPoints.length;\n        var bPoints = b['calcPoints'];\n        var bLen = bPoints.length;\n        // If any of the edge normals of A is a separating axis, no intersection.\n        for(var i = 0; i < aLen; i++) {\n            if(isSeparatingAxis(a['pos'], b['pos'], aPoints, bPoints, a['normals'][i], response)) {\n                return false;\n            }\n        }\n        // If any of the edge normals of B is a separating axis, no intersection.\n        for(var i = 0; i < bLen; i++) {\n            if(isSeparatingAxis(a['pos'], b['pos'], aPoints, bPoints, b['normals'][i], response)) {\n                return false;\n            }\n        }\n        // Since none of the edge normals of A or B are a separating axis, there is an intersection\n        // and we've already calculated the smallest overlap (in isSeparatingAxis).  Calculate the\n        // final overlap vector.\n        if(response) {\n            response['a'] = a;\n            response['b'] = b;\n            response['overlapV'].copy(response['overlapN']).scale(response['overlap']);\n        }\n        return true;\n    }\n    SAT['testPolygonPolygon'] = testPolygonPolygon;\n\n    return SAT;\n}));\n",
    "/*\n * A place for generic math, set/get methods, and other small functions.\n * Also used for global data structures, enums, and functions.\n */\nvar utils = (function() {\n    var cboxMenu;\n\n    return {\n        /*\n         * extends an oldObj into a newObj\n         * while keeping certain objects properties in sync\n         */\n        extend: function(newObj, oldObj) {\n            // merge-copy current oldObj into newObj\n            $.extend(newObj, oldObj);\n\n            // force newObj to get oldObj's imgReady property\n            var prop = 'imgReady';\n            Object.defineProperty(newObj, prop, {\n                get: function () {\n                    return oldObj[prop];\n                },\n                //set: function (arg) {\n                //    oldObj[prop] = arg;\n                //},\n                //configurable: true\n            });\n\n        },\n\n        speed2scale: function(speed) {\n            return -0.5*speed + 2;\n        },\n\n        /*\n            Returns a random float between a and b.\n\n            @param(number) min The min floating point number.\n            @param(number) max The max floating point number.\n            @param(?number) precision The number of decimal precision places. (2 (hundredths place) by default)\n        */\n        randF: function(min, max, precision) {\n            if(typeof (precision) === 'undefined') {\n                precision = 2; // hundredths place\n            }\n\n            return parseFloat(Math.min(min + (Math.random() * (max - min)), max).toFixed(precision));\n        },\n\n        repeatAction: function(timeStep, numTimes, callback) {\n            var num = 0;\n            var theAnimation = setInterval(function () {\n                if (num++ > numTimes) {\n                    clearInterval(theAnimation);\n                }\n                else {\n                    callback();\n                }\n            }, timeStep);\n        },\n\n        deathSequence: function() {\n            if (!game.over) {\n                game.over = true;\n\n                audio.heroDeath.play();\n                audio.bgMusic.muted = true;\n\n                setTimeout(function() {\n                    Graphics.fadeCanvas(function() {\n                        if((hero.lives - 1) < 0) {\n                            alert(\"You Lose\");\n                            location.reload();\n                        }\n                        else {\n                            --hero.lives;\n                        }\n\n\n                        level.reset();\n                        level.curLvl.deinit();\n                        level.curLvl.init();\n\n                        if (audio.isOn)\n                            audio.bgMusic.muted = false;\n                    });\n                }, 2600);\n            }\n        },\n\n        degToRad: function(deg) {\n            return deg * 0.0174532925199432957;\n        },\n\n        revFactorial: function(n) {\n            var count = 2;\n            var result = n;\n\n            while(result !== 1) {\n                console.log(result + '/' + count + '=');\n                result /= count;\n\n                if(result === 0) {\n                    return -1;\n                }\n                else if(result === 1) {\n                    return count;\n                }\n                else {\n                    ++count;\n                }\n            }\n        },\n\n        getTimeObj: function(t) {\n            if(t === 0) {\n                return {min: '00', sec: '00'};\n            }\n            \n            var min = Math.floor(t / 60);\n            var sec = t % 60;\n\n            if(sec < 10) {\n                sec = '0' + sec;\n            }\n\n            if(min < 10) {\n                min = '0' + min;\n            }\n\n            return {\n                min: min,\n                sec: sec\n            };\n        },\n\n        browser: function() {\n            var ua = navigator.userAgent,\n                     tem,\n                     M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\\/))\\/?\\s*([\\d\\.]+)/i) || []\n            ;\n\n            if(/trident/i.test(M[1])) {\n                tem = /\\brv[ :]+(\\d+(\\.\\d+)?)/g.exec(ua) || [];\n                    return 'IE '+(tem[1] || '');\n            }\n\n            M = M[2]? [M[1], M[2]]:[navigator.appName, navigator.appVersion, '-?'];\n\n            if ((tem = ua.match(/version\\/([\\.\\d]+)/i)) != null)\n                M[2] = tem[1];\n\n            return M.join(' ');\n        },\n\n        /**** Debug Printers ****/\n        // A method to print to the console less frequently then within the game loop.\n        printSlow: function(msg) {\n            if(game.actualTime % 10 === 0) {\n                console.log(msg);\n            }\n        },\n\n\t\tprintMouse: function() {\n\t\t    $('canvas').on('mousemove', function (e) {\n\t\t        console.log(e.offsetX, e.offsetY);\n\t\t    });\n\t\t},\n\n\t\tprintDir: function (dir) {\n\t\t    switch (dir) {\n\t\t        case 0:\n\t\t            console.log(\"Dir.NONE\");\n\t\t            break;\n\t\t        case 1:\n\t\t            console.log(\"Dir.TOP\");\n\t\t            break;\n\t\t        case 2:\n\t\t            console.log(\"Dir.BOT\");\n\t\t            break;\n\t\t        case 3:\n\t\t            console.log(\"Dir.LEFT\");\n\t\t            break;\n\t\t        case 4:\n\t\t            console.log(\"Dir.RIGHT\");\n\t\t            break;\n\t\t        case 5:\n\t\t            console.log(\"Dir.IN\");\n\t\t            break;\n\t\t        default:\n\t\t            console.log(\"Dir.unknown\");\n\t\t    }\n\t\t},\n\n\t\ttoggleMenu: function() {\n\t\t    if ($('#colorbox').css('display') === 'block') {\n\t\t        cboxMenu.colorbox.close();\n\t\t    }\n\t\t    else {\n\t\t        cboxMenu = $.colorbox({\n\t\t            html: $('.gameInstructions').html(),\n\t\t            width: 320,\n\t\t            height: 530\n\t\t        });\n\t\t    }\n\t\t},\n\n\t\ttoggleFullScreen: function() {\n\t\t    // fill browser window\n\t\t    if ($('body').hasClass('fullscreen')) {\n\t\t        $('.canvasWrap').css({\n\t\t            width: '',\n\t\t            marginLeft: ''\n\t\t        });\n\n\t\t        document.body.classList.remove('fullscreen');\n\t\t    }\n\t\t    else {\n\t\t        document.body.classList.add('fullscreen');\n\n\t\t        var scaledW = $(window).height() * 1.777778;\n\n\t\t        $('.canvasWrap').css({\n\t\t            width: scaledW,\n\t\t            marginLeft: -scaledW / 2\n\t\t        });\n\t\t    }\n\n            // fullscreen API\n            //if (!document.fullscreenElement &&    // alternative standard method\n            //    !document.mozFullScreenElement && !document.webkitFullscreenElement) {  // current working methods\n\n            //    if (canvas.requestFullscreen) {\n            //        canvas.requestFullscreen();\n            //    }\n            //    else if (canvas.mozRequestFullScreen) {\n            //        canvas.mozRequestFullScreen();\n            //    }\n            //    else if (canvas.webkitRequestFullscreen) {\n            //        canvas.webkitRequestFullscreen(); //Element.ALLOW_KEYBOARD_INPUT\n            //    }\n            //}\n            //else {\n            //    if (document.cancelFullScreen) {\n            //        document.cancelFullScreen();\n            //    }\n            //    else if (document.mozCancelFullScreen) {\n            //        document.mozCancelFullScreen();\n            //    }\n            //    else if (document.webkitCancelFullScreen) {\n            //        document.webkitCancelFullScreen();\n            //    }\n            //}\n        }\n\n\t};\n})();\n\n\n// global enums\nvar Dir = Object.freeze({\n    NONE: 0,\n    TOP: 1,\n    BOT: 2,\n    LEFT: 3,\n    RIGHT: 4,\n    IN: 5,\n    UP: 6,\n    DOWN: 7,\n    UP_RIGHT: 8,\n    DOWN_RIGHT: 9\n});\n\nvar Color = Object.freeze({\n    LIGHT_BROWN: \"#c44525\",\n    DARK_BROWN: \"#672819\",\n    LIGHT_GREEN: \"#166a38\",\n    SILVER: \"#c0c0c0\",\n    BLACK: \"#000\",\n    GOLD: \"#ddaa13\",\n    ORANGE: \"#ff6a00\"\n});",
    "var audio = (function () {\n\n    return {\n        bgMusic: new Audio(\"audio/firstChiptune/firstChiptune.mp3\"),\n        enterSound: new Audio(\"audio/synthetic_explosion_1.mp3\"),\n        exitSound: new Audio(\"audio/annulet.mp3\"),\n        itemPickedUp: new Audio(\"audio/life_pickup.mp3\"),\n        heartbeat: new Audio(\"audio/heartbeat.mp3\"),\n        jump: new Audio(\"audio/jump.mp3\"),\n        thud: new Audio(\"audio/thud.mp3\"),\n        step: new Audio(\"audio/step.mp3\"),\n        effort: new Audio(\"audio/woosh.mp3\"),\n        discovery: new Audio(\"audio/spell3.mp3\"),\n        enemyDeath: new Audio(\"audio/death.mp3\"),\n        heroDeath: new Audio(\"audio/DiscsOfTron_Cascade.mp3\"),\n        enchant: new Audio(\"audio/enchant.mp3\"),\n        isOn: false,\n\n\n        init: function(){\n            audio.bgMusic.loop = true;\n            audio.bgMusic.volume = 0.7;\n            audio.bgMusic.pause();\n\n            audio.enemyDeath.volume = 0.6;\n            audio.jump.volume = 0.4;\n            audio.thud.volume = 0.78;\n            audio.discovery.volume = 0.7;\n\n            audio.mute(true);\n            $(document).on('click', '.audioState', audio.handleMuteButton);\n\n            $('.menu').on('click', function(e) {\n                e.preventDefault();\n                utils.toggleMenu();\n            });\n\n            // enable audio on start\n            audio.handleMuteButton()\n        },\n\n        lvlComplete: function () {\n            audio.bgMusic.pause();\n\n            var newBgMusic;\n            \n            switch(game.lvl) {\n                case 0:\n                    audio.enterSound.play();\n                    return;\n                default:\n                    audio.exitSound.play();\n                    newBgMusic = \"sweetAcoustic.mp3\";\n                    break;\n            }\n\n            setTimeout(function() {\n                audio.bgMusic = new Audio('audio/' + newBgMusic);\n                audio.bgMusic.loop = true;\n                audio.bgMusic.volume = 0.45;\n\n                audio.isOn ?\n                    audio.bgMusic.play() :\n                    audio.bgMusic.pause();\n            }, 1000);\n        },\n\n        updateBgMusic: function() {\n            audio.bgMusic.pause();\n\n            var newBgMusic;\n\n            switch(game.lvl) {\n                case 1:\n                case 2:\n                    newBgMusic = \"inspiredBySparkMan/sparkBoy.mp3\";\n                    break;\n                case 3:\n                    newBgMusic = \"bossBeat/bossBeat.mp3\";\n                    break;\n                default:\n                    newBgMusic = \"sweetAcoustic.mp3\";\n                    break;\n            }\n\n            setTimeout(function () {\n                audio.bgMusic = new Audio(\"audio/\" + newBgMusic);\n                audio.bgMusic.loop = true;\n                audio.bgMusic.volume = 0.45;\n\n                audio.isOn ?\n                    audio.bgMusic.play() :\n                    audio.bgMusic.pause();\n            }, 1000);\n        },\n\n        play: function (sound, stopPrev) {\n            stopPrev = (typeof (stopPrev) !== \"undefined\") ? stopPrev : true;\n\n            if (sound.ended)\n                sound.play();\n            else {\n                if (stopPrev || sound.currentTime === 0) {\n                    sound.pause();\n                    sound.currentTime = 0;\n                    sound.play();\n                }\n            }\n        },\n\n        handleMuteButton: function() {\n            if ($('.audioState').hasClass('off')) {\n                $('.audioState iron-icon').attr('icon', 'av:volume-up');\n                $('.audioState').removeClass('off');\n                $('.audioState').addClass('on');\n\n                audio.mute(false);\n            }\n            else {\n                $('.audioState iron-icon').attr('icon', 'av:volume-off');\n                $('.audioState').removeClass('on');\n                $('.audioState').addClass('off');\n\n                audio.mute(true);\n            }\n        },\n\n        mute: function (onOrOff) {\n            audio.discovery.muted =\n            audio.enterSound.muted =\n            audio.bgMusic.muted =\n            audio.itemPickedUp.muted =\n            audio.heartbeat.muted =\n            audio.effort.muted = \n            audio.thud.muted = \n            audio.jump.muted = \n            audio.step.muted = \n            audio.enemyDeath.muted =\n            audio.heroDeath.muted =\n            audio.enchant.muted =\n            audio.exitSound.muted =\n                onOrOff;\n\n            onOrOff ?\n                audio.bgMusic.pause() :\n                audio.bgMusic.play();\n\n            audio.isOn = !onOrOff;\n        }\n    };\n})();",
    "/// <reference path=\"../linker.js\" />\n\n/*\n    A library of generic graphics functions.\n*/\nvar Graphics = (function () {\n\n    var alpha = 1,\n        canvasTransition = null,\n        swellN = 250,\n        swellTimer = swellN,\n        swellRadius = swellN,\n        cloundMaxY = 170\n    ;\n\n    return {\n        ticker: 1,              // 1.0 --> 0.0 --> 1.0 --> ...\n        tickerStep: 0.01,\n        fadeOut: false,\n        projectX: 8,\n        projectY: 11,\n\n\n        fadeCanvas: function (callback) {\n            if (utils.browser() === \"MSIE 9.0\") {\n                callback();\n            }\n            else {\n                $(canvas).removeClass(\"preTransition\");\n                $(canvas).addClass(\"duringTransition\");\n\n                canvasTransition = $(canvas).on(\"transitionend webkitTransitionEnd oTransitionEnd MSTransitionEnd\", function () {\n                    canvasTransition.off();\n\n                    $(this).removeClass(\"duringTransition\");\n                    $(this).addClass(\"preTransition\");\n\n                    callback();\n                });\n            }\n        },\n\n        blinkText: function (fontSize, x, y, str) {\n            str = (typeof (str) !== \"undefined\") ? str : \"PRESS ENTER\";\n\n            if (Graphics.ticker >= 1.35 || Graphics.ticker <= Graphics.tickerStep) {\n                Graphics.fadeOut = !Graphics.fadeOut;\n            }\n\n            if (Graphics.ticker >= 1) {\n                alpha = 1;\n            }\n            else if (Graphics.ticker <= Graphics.tickerStep) {\n                alpha = 0;\n            }\n            else {\n                alpha = Graphics.ticker;\n            }\n\n            ctx.font = fontSize + \"px 'Press Start 2P'\";\n            var tmpW = ctx.measureText(str).width;\n            ctx.fillStyle = \"rgba(233, 233, 233,\" + alpha + ')';\n            ctx.fillText(str, x - tmpW / 2, y);\n        },\n\n        /*\n            Converts a rectangle into a 'skewed rectangle' polygon\n\n            @param(number) x\n            @param(number) y\n            @param(number) w\n            @param(number) h\n            @return (SAT.Polygon)\n        */\n        getSkewedRect: function (x, y, w, h) {\n            y += Graphics.projectY / 2;\n\n            var poly = new SAT.Polygon(new SAT.Vector(x, y), [\n                new SAT.Vector(),\n                new SAT.Vector(w - Graphics.projectX, 0),\n                new SAT.Vector(w, Graphics.projectY),\n                new SAT.Vector(w, h),\n                new SAT.Vector(Graphics.projectX, h),\n                new SAT.Vector(0, h - Graphics.projectY)\n            ]);\n\n            return poly;\n        },\n\n        getStairPoly: function(x, y, w, h, dir) {\n            var poly;\n            if(dir === Dir.UP_RIGHT) {\n                poly = new SAT.Polygon(new SAT.Vector(x, y), [\n                    new SAT.Vector(),\n                    new SAT.Vector(w - Graphics.projectX, -h),\n                    new SAT.Vector(w, -h + Graphics.projectY),\n                    new SAT.Vector(w, 0),\n                    new SAT.Vector(Graphics.projectX, h),\n                    new SAT.Vector(0, h - Graphics.projectY)\n                ]);\n            }\n            else {\n                poly = new SAT.Polygon(new SAT.Vector(x, y), [\n                    new SAT.Vector(),\n                    new SAT.Vector(w - Graphics.projectX, h - Graphics.projectY - 5),\n                    new SAT.Vector(w, h - 4),\n                    new SAT.Vector(0, h),\n                    new SAT.Vector(Graphics.projectX, h),\n                    new SAT.Vector(0, h - Graphics.projectY)\n                ]);\n            }\n\n            return poly;\n        },\n\n        setClouds: function(width){\n            var x = 0;\n            \n            while(x < width) {\n                x = Graphics.spawnCloud(x);\n            }\n        },\n\n        spawnCloud: function (x) {\n            var y = Math.floor(Math.random() * cloundMaxY);\n            var speed = utils.randF(2, 3.3, 1);\n            var width = utils.speed2scale(speed) * 120; // 120px is clound.png width; TODO: fix GameObj image width calculation\n\n            x += width + Math.floor((Math.random() * 20) + 8);\n\n            var obj = new GameObj(JQObject.CLOUD, x, 10 + y, 0, 0, \"cloud.png\");\n            obj.speed = speed;\n            obj.distTraveled = 0;\n            obj.distToTravel = x + width;\n\n            level.bg.push(obj);\n\n            return x;\n        },\n\n        drawLadder: function (platform) {\n            var x = platform.pos.x,\n                y = platform.pos.y,\n                w = platform.edges[0].x,\n                h = platform.edges[1].y\n            ;\n\n            // sides\n            ctx.fillStyle = Color.LIGHT_BROWN;\n            ctx.fillRect(x, y, 5, h);\n            ctx.fillRect(x + w-5, y, 5, h);\n\n            // rungs\n            for (var i = 13; i < h; i+=20) {\n                ctx.fillRect(x, y+i, w, 8);\n            }\n        },\n\n        getScale: function(x, y) {\n            var theScale = {};\n\n            for(var i = 0; i < 2; ++i) {\n                var dir = (i === 0) ? Dir.LEFT : Dir.RIGHT;\n\n                theScale[dir] = new GameObj(JQObject.SCALE, x + i * 300, y, 150, 46);\n                theScale[dir].holdingItem = null; // TODO: fix api\n            }\n\n            theScale.vBar = new GameObj(JQObject.SCALEBG,\n                theScale[Dir.LEFT].pos.x + theScale[Dir.LEFT].w + 70,\n                HALFH - game.padFloor,\n                10,\n                HALFH\n            );\n            theScale.vBar.collidable = false;\n\n            theScale.hBar = new GameObj(JQObject.SCALEBG,\n                theScale[Dir.LEFT].pos.x + theScale[Dir.LEFT].w / 2,\n                HALFH,\n                300,\n                10\n            );\n            theScale.hBar.x2 = theScale.hBar.pos.x + theScale.hBar.w;\n            theScale.hBar.y2 = theScale.hBar.pos.y;\n            theScale.hBar.collidable = false;\n            theScale.hBar.visible = false;\n\n            theScale[Dir.LEFT].hBar = theScale.hBar;\n            theScale[Dir.LEFT].side = Dir.LEFT;\n            theScale[Dir.LEFT].otherSide = theScale[Dir.RIGHT];\n\n            theScale[Dir.RIGHT].hBar = theScale.hBar;\n            theScale[Dir.RIGHT].side = Dir.RIGHT;\n            theScale[Dir.RIGHT].otherSide = theScale[Dir.LEFT];\n\n            return theScale;\n        },\n\n        drawScale: function (platform) {\n            var x = platform.pos.x,\n                y = platform.pos.y,\n                w = platform.edges[0].x,\n                h = platform.edges[1].y\n            ;\n            \n            // draw top border 1px above bounding box\n            ctx.fillStyle = Color.BLACK;\n            ctx.fillRect(x, y - 1, w, 1);\n\n            // draw platform\n            ctx.fillStyle = Color.DARK_BROWN;\n            ctx.fillRect(x, y, w, h);\n        },\n\n        drawScaleChains:function(x, y, scale) {\n            ctx.beginPath();\n            ctx.moveTo(x, y);\n            ctx.lineTo(scale.pos.x, scale.pos.y);\n            ctx.stroke();\n            ctx.closePath();\n\n            ctx.beginPath();\n            ctx.moveTo(x, y);\n            ctx.lineTo(scale.pos.x + scale.w / 2, scale.pos.y);\n            ctx.stroke();\n            ctx.closePath();\n\n            ctx.beginPath();\n            ctx.moveTo(x, y);\n            ctx.lineTo(scale.pos.x + scale.w, scale.pos.y);\n            ctx.stroke();\n            ctx.closePath();\n        },\n\n        drawScaleBg: function(theScale){\n            ctx.strokeStyle = \"#000\";\n            ctx.lineWidth = 10;\n\n            // hBar\n            ctx.beginPath();\n            ctx.moveTo(theScale.hBar.pos.x, theScale.hBar.pos.y);\n            ctx.lineTo(theScale.hBar.x2, theScale.hBar.y2);\n            ctx.stroke();\n            ctx.closePath();\n            \n            // left scale chains\n            Graphics.drawScaleChains(theScale.hBar.pos.x, theScale.hBar.pos.y, theScale[Dir.LEFT]);\n\n            // right scale chains\n            Graphics.drawScaleChains(theScale.hBar.x2, theScale.hBar.y2, theScale[Dir.RIGHT]);\n        },\n\n        /*\n            @param(SAT.Polygon) poly An SAT.Polygon.\n            @param(?Color) fillStyle The fill style of the polygon\n            @param(?number, ?number) trans A translated x and y dimension.\n        */\n        drawPoly: function(poly, fillStyle, trans) {\n            var y = poly.pos.y - Graphics.projectY;\n            var x = poly.pos.x;\n\n            if(typeof (trans) !== \"undefined\") {\n                x += trans.x;\n                y += trans.y;\n            }\n\n            ctx.fillStyle = (typeof(fillStyle) !== \"undefined\") ? fillStyle : \"orange\";\n            ctx.beginPath();\n            ctx.moveTo(x, y);\n\n            for(var i = 1; i < poly.points.length; ++i) {\n                ctx.lineTo(x + poly.points[i].x, y + poly.points[i].y);\n            }\n\n            ctx.closePath();\n            ctx.fill();\n        },\n\n        drawHill: function(poly) {\n            for(var i = 0; i < game.padFloor - 15; ++i) {\n                Graphics.drawPoly(poly, Color.LIGHT_BROWN, { x: 0, y: i });\n            }\n            Graphics.drawPoly(poly, Color.DARK_BROWN, { x: Graphics.projectX, y: game.padFloor});\n            //Graphics.drawPoly(poly, Color.DARK_BROWN, { x: 10, y: game.padFloor -2 });\n        },\n\n        getHill: function(x, y, w, h) {\n            var arr = [new SAT.V()];\n\n            x += w / 2;\n            y += Graphics.projectY;\n\n            var a = w / 2,  // the horizontal radius\n                b = h / 2,  // the vertical radius\n                t = 180,    // the angle between the horizontal radius and a vector to any point on the curve (in degrees)\n                xx,\n                yy\n            ;\n\n            while(t !== 360) {\n                xx = a * Math.cos(utils.degToRad(t));\n                yy = b * Math.sin(utils.degToRad(t++));\n                arr.push(new SAT.V(xx, yy));\n            }\n\n            arr.push(new SAT.V(w/2));\n\n            return new SAT.Polygon(new SAT.V(x, y), arr);\n        },\n\n        drawPlatform: function (poly) {\n            var y = poly.pos.y - Graphics.projectY / 2;\n\n            // top\n            ctx.fillStyle = Color.LIGHT_BROWN;\n            ctx.beginPath();\n            ctx.moveTo(poly.pos.x, y);\n            ctx.lineTo(poly.pos.x + poly.points[1].x, y + poly.points[1].y);\n            ctx.lineTo(poly.pos.x + poly.points[2].x, y + poly.points[2].y);\n            ctx.lineTo(poly.pos.x + Graphics.projectX, y + Graphics.projectY);\n            ctx.closePath();\n            ctx.fill();\n\n            // body\n            ctx.fillStyle = Color.DARK_BROWN;\n            ctx.beginPath();\n            ctx.moveTo(poly.pos.x + poly.points[2].x, y + poly.points[2].y);\n            ctx.lineTo(poly.pos.x + poly.points[3].x, y + poly.points[3].y);\n            ctx.lineTo(poly.pos.x + poly.points[4].x, y + poly.points[4].y);\n            ctx.lineTo(poly.pos.x + poly.points[5].x, y + poly.points[5].y);\n            ctx.lineTo(poly.pos.x + poly.points[0].x, y + poly.points[0].y);\n            ctx.lineTo(poly.pos.x + Graphics.projectX, y + Graphics.projectY);\n            ctx.closePath();\n            ctx.fill();\n        },\n\n        drawPlatformStatus: function (platform) {\n            var x = platform.pos.x,\n                y = platform.pos.y,\n                w = platform.w,\n                h = platform.h,\n                theShape = 26,\n                halfTheShape = theShape/2,\n                midX = x + w/2 - halfTheShape,\n                midY = y + h/2 - halfTheShape\n            ;\n\n            ctx.lineWidth = 3;\n\n            if (platform.holdingItem !== null && platform.holdingItem.type === JQObject.CRATE) {\n                // draw check mark\n                ctx.strokeStyle = \"green\";\n\n                --midY;\n                ctx.beginPath();\n                ctx.moveTo(midX, midY + halfTheShape);\n                ctx.lineTo(midX + halfTheShape, midY + theShape);\n                ctx.moveTo(midX + halfTheShape-1, midY + theShape);\n                ctx.lineTo(midX + theShape+2, midY+2);\n                ctx.stroke();\n                ctx.closePath();\n\n            }\n            else {\n                // draw 'X'\n                ctx.strokeStyle = \"red\";\n\n                ctx.beginPath();\n                ctx.moveTo(midX, midY);\n                ctx.lineTo(midX + theShape, midY + theShape);\n                ctx.moveTo(midX, midY + theShape);\n                ctx.lineTo(midX + theShape, midY);\n                ctx.stroke();\n                ctx.closePath();\n            }\n        },\n\n        // @param(GameObj) gObj A game object.\n        drawDoor: function (gObj) {\n            // alias\n            var x = gObj.pos.x;\n            var y = gObj.pos.y;\n            var w = gObj.w;\n            var h = gObj.h;\n\n            // door\n            ctx.fillStyle = Color.LIGHT_BROWN;\n            ctx.fillRect(x + 2, y + 2, w - 2, h - 2);\n\n            ctx.fillStyle = Color.DARK_BROWN;\n\n            ctx.fillRect(x, y, 2, h);   // left frame\n            ctx.fillRect(x, y, w, 2);   // top frame\n            ctx.fillRect(x + w, y, 2, h);   // right frame\n\n            // door handle\n            ctx.beginPath();\n            ctx.arc(x + w - (w / 3.2), y + h - (h / 3.4), 4, 0, 2 * Math.PI, false);\n            ctx.fill();\n            ctx.closePath();\n\n            // label\n            ctx.font = \"19px 'Press Start 2P'\";\n            ctx.fillStyle = Color.DARK_BROWN;\n            ctx.fillText(\"EXIT\", x - 15, y - 3);\n            ctx.fillStyle = Color.LIGHT_BROWN;\n            ctx.fillText(\"EXIT\", x - 18, y - 5);\n        },\n\n        getDoorBgGrad: function(){\n            var grad = ctx.createRadialGradient(\n                level.bgColor.gradX,\n                level.bgColor.gradY,\n                14,\n                level.bgColor.gradX,\n                level.bgColor.gradY,\n                490 - swellRadius\n            );\n\n            if(--swellTimer === -swellN) {\n                swellTimer = swellN;\n                swellRadius = swellN;\n            }\n            else if(swellTimer < 0) {\n                ++swellRadius;\n            }\n            else {\n                --swellRadius;\n            }\n\n            grad.addColorStop(0, level.bgColor.c0);\n            //grad.addColorStop(0, \"rgb(42,126,76)\");\n            //grad.addColorStop(1, \"rgb(22,106,56)\");\n            grad.addColorStop(1, level.bgColor.c1);\n\n            return grad;\n        },\n\n        drawEllipse: function (x, y, w, h) {\n            var kappa = 0.5522848,\n\t\t\t\tox = (w / 2) * kappa, // control point offset horizontal\n\t\t\t\toy = (h / 2) * kappa, // control point offset vertical\n\t\t\t\txe = x + w, // x-end\n\t\t\t\tye = y + h, // y-end\n\t\t\t\txm = x + w / 2, // x-middle\n\t\t\t\tym = y + h / 2 // y-middle\n            ;\n\n            ctx.beginPath();\n            ctx.moveTo(x, ym);\n            ctx.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y);\n            ctx.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym);\n            ctx.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);\n            ctx.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);\n            ctx.closePath();\n            ctx.fill();\n        },\n\n        drawRotate: function (img, x, y, angle) {\n            ctx.save();\n\n            ctx.translate(x, y);\t\t\t\t\t\t\t\t// move co-ord sys to img origin\n            ctx.rotate(utils.degToRad(angle));\n            ctx.translate(-img.width * 0.5, -img.height * 0.5); // move to top left of img\n\n            //ctx.scale(0.75, 0.75);\n            ctx.drawImage(img, 0, 0);\n\n            ctx.restore();\n        }\n    };\n})();\n\n\n/* Images */\n//lvl = new Array(NUM_LEVELS),\n//lvlBgImg = {}\n//function loadBgImages(imgArr, callback) {\n//    var count = 0;\n\n//    for (var key in imgArr) {\n//        if (imgArr[key] !== \"none\") {\n//            lvlBgImg[key] = new Image();\n//            lvlBgImg[key].onload = function () {\n//                callback(this.num);\n//            };\n\n//            lvlBgImg[key].src = imgArr[key];\n//            lvlBgImg[key].num = count;\n//        }\n\n//        ++count;\n//    }\n//}\n\n//for (var i = 0; i < NUM_LEVELS; ++i) {\n//    lvl[i] = {\n//        status: false,\n//        bgColor: '#' + Math.floor(Math.random() * 16777215).toString(16)\n//    };\n//}\n\n//loadBgImages({\n//    lvl0: \"img/lvl0.jpg\",\n//    lvl1: \"none\"\n//}, function (num) {\n//    lvl[num].status = true;\n//});\n\n\n\n\n//var wasClicked = false;\n//$(\".resize\").on(\"click\", function(){\n//    if (wasClicked) {\n//        $(canvas).css({ width: \"\", height: \"\" });\n//        $(this).attr(\"class\", \"resize off\");\n//        $(this).children(\"span\").attr(\"class\", \"icon-expand\");\n//    }\n//    else {\n//        $(canvas).css({ width: \"100%\" });\n\n//        // fix for IE\n//        var width = $(canvas).width();\n//        $(canvas).css({ height: 0.611 * width });\n\n\n//        $(this).attr(\"class\", \"resize on\");\n//        $(this).children(\"span\").attr(\"class\", \"icon-contract\");\n//    }\n\n//    wasClicked = !wasClicked;\n//});\n",
    "/// <reference path=\"../linker.js\" />\n\n// A library of generic physics functions.\nvar Physics = (function () {\n\n\n    return {\n        // TODO: speed up by checking if a does NOT intersect with b (i.e. using OR)\n        // Uses simple Speculative Contacts\n        isCollision: function (a, b, moe, isLvl) {\n            var aX = (typeof (isLvl) !== \"undefined\") ? a.pos.x + a.lvlX : a.pos.x;\n\n            if ((aX + moe <= (b.pos.x + b.w)) && // a is to the left of the right side of b\n\t\t\t\t(b.pos.x + moe <= (aX + a.w)) && // a is to the right of the left side of b\n\t\t\t\t(a.pos.y + moe <= (b.pos.y + b.h)) && // a is higher than the bot of b\n\t\t\t\t(b.pos.y + moe <= (a.pos.y + a.h)) \t  // a is lower than the top of b\n\t\t\t) {\n                return true;\n            }\n\n            return false;\n        },\n        \n        // Checks for a collision between two polygons (uses SAT and AABB).\n        // @param(GameObj) a A game object.\n        // @param(GameObj) b A game object.\n        // @param(function) callback A function invoked with SAT.Response ONLY IF a collision occurred.\n        isSATcollision: function (a, b, callback) {\n            var r = new SAT.Response();\n            if (SAT.testPolygonPolygon(a, b, r)) {\n                callback(r);\n            }\n        },\n\n        // Tests collision between gObj and level.objs[]\n        // @param(GameObj) gObj A game object (or subclass).\n        // @param(function) callback A callback function.  Called with a SAT.Response().\n        testObjObjs: function (gObj, callback) {\n            var response = new SAT.Response();\n\n            for(var i = 0; i < level.objs.length; ++i) {\n                var obj = level.objs[i];\n\n                if (typeof(obj.collidable) === \"undefined\"\n                    //&& obj !== gObj         // checks if object is in list (by reference)\n                ) {\n\n                    // Check Level Object Collision\n                    var collided = SAT.testPolygonPolygon(gObj, obj, response);\n\n                    // Respond to Level Object Collision\n                    if(collided) {\n                        callback(response);\n                    }\n\n                    response.clear();\n                }\n            }\n\n            // idea to fix \"hooking\" around edges of platform\n            // http://stackoverflow.com/a/1355695/353166\n        },\n\n        // Tests collision between item and level.items[]\n        // @param(GameItem) item A game item.\n        // @param(function) callback A callback function.  Called with a SAT.Response().\n        testItemItems: function (item, callback) {\n            var response = new SAT.Response();\n\n            for (var i = 0; i < level.items.length; ++i) {\n                if (!level.items[i].isBeingHeld) {\n                        \n                    if (level.items[i].type !== JQObject.CRATE)       // TODO: allow non-crates\n                        continue;\n\n                    var collided = SAT.testPolygonPolygon(item, level.items[i], response);\n                        \n                    if (collided) {\n                        if (response.overlapN.y === 1) {   // a is on top of b\n                            response.a.pos.x -= response.overlapV.x;\n                            response.a.pos.y -= response.overlapV.y;\n\n                            callback(response);\n                            break;\n                        }\n                    }\n\n                    response.clear();\n                }\n            }\n        },\n\n        // Tests collision between hero and the level.items[]\n        // @param(function) callback A callback function.  Called with a SAT.Response and the index of the item.\n        testHeroItems: function (callback) {\n            for (var i = 0; i < level.items.length; ++i) {\n                if (level.items[i].visible) {\n                    Physics.isSATcollision(hero, level.items[i], function (r) {\n                            callback(r, i);\n                    });\n                }\n            }\n        },\n\n\n    handleScale: function() {\n            var numCratesOnScales = 0;\n\n            for(var i = 0; i < level.objs.length; ++i) {\n                if(level.objs[i].type === JQObject.SCALE &&\n                    typeof (level.objs[i].holdingItem) !== \"undefined\" && level.objs[i].holdingItem !== null &&\n                    level.objs[i].holdingItem.type === JQObject.CRATE\n                ) {\n                    ++numCratesOnScales;\n                }\n            }\n\n            var doLadder = (numCratesOnScales === 2);\n\n            if(doLadder) {\n                audio.discovery.play();\n\n                var result = $.grep(level.objs, function(e) {\n                    return e.type === JQObject.LADDER;\n                });\n                result[0].visible = true;\n            }\n\n            return doLadder;\n        },\n\n        // Tests collision between items\n        //testAllItems: function () {\n        //    var response = new SAT.Response();\n\n        //    for (var i = 0; i < level.items.length; ++i) {\n        //        for (var j = 0; j < level.items.length; ++j) {\n        //            if (i !== j && !level.items[i].isBeingHeld && !level.items[j].isBeingHeld) {\n                        \n        //                if (level.items[i].type !== JQObject.CRATE || level.items[j].type !== JQObject.CRATE)       // TODO: allow non-crates\n        //                    continue;\n\n        //                var collided = SAT.testPolygonPolygon(level.items[i], level.items[j], response);\n                        \n        //                if (collided) {\n        //                    if (response.overlapN.y === 1) {   // a is on top of b\n        //                        response.a.pos.x -= response.overlapV.x;\n        //                        response.a.pos.y -= response.overlapV.y;\n\n        //                        response.a.isOnObj = true;\n        //                        response.a.onObj = response.b;\n        //                        response.b.grabbable = false;\n\n        //                        level.items.push(response.a);\n        //                    }\n        //                }\n\n        //                response.clear();\n        //            }\n        //        }\n        //    }\n        //}\n    };\n})();\n",
    "/// <reference path=\"../linker.js\" />\n\nvar JQObject = Object.freeze({\n    EMPTY: 0,\n    CRATE: 1,\n    LADDER: 2,\n    SACK: 3,\n    ENEMY: 4,\n    CASH: 5,\n    DOOR: 6,\n    SCALE: 7,\n    CLOUD: 8,\n    PLATFORM: 9,\n    SHURIKEN: 10,\n    SLOPE: 11,\n    POLY: 12,\n    HILL: 13,\n    ELEVATOR: 14,\n    SCALEBG: 15,\n    FIREBALL: 16\n});\n\nvar JQObject_names = Object.freeze({\n    0: \"EMPTY\",\n    1: \"CRATE\",\n    2: \"LADDER\",\n    3: \"SACK\",\n    4: \"ENEMY\",\n    5: \"CASH\",\n    6: \"DOOR\",\n    7: \"SCALE\",\n    8: \"CLOUD\",\n    9: \"PLATFORM\",\n    10: \"SHURIKEN\",\n    11: \"SLOPE\",\n    12: \"POLY\",\n    13: \"HILL\",\n    14: \"ELEVATOR\",\n    15: \"SCALEBG\",\n    16: \"FIREBALL\"\n});\n\n/*\n    GameObj is the base class from which all objects in the game inherit from.\n    Every GameObj has a SAT.Vector (pos);       TODO: make Vector not Polygon\n    \n    @param(JQObject) type The type of the object.\n    @param(number) x The x position of the object.\n    @param(number) y The y position of the object.\n    @param(number?) w The width of the object.\n    @param(number?) h The height of the object.\n    @param(Image?) src The filename of the object sprite.  unused by default\n    @param(Dir) dir The slope direction. TODO: move to own class\n\n    @constructor\n*/\nvar GameObj = function (type, x, y, w, h, src, dir) {\n    this.dir = dir;\n\n    // this.pos\n    if (type === JQObject.PLATFORM || type === JQObject.ELEVATOR) {\n        $.extend(this, Graphics.getSkewedRect(x, y, w, h));\n    }\n    else if(type === JQObject.SLOPE) {\n        $.extend(this, Graphics.getStairPoly(x, y, w, h, dir));\n    }\n    else if(type === JQObject.HILL) {\n        $.extend(this, Graphics.getHill(x, y, w, h));\n    }\n    else if(type === JQObject.POLY) {\n        // custom polygon\n    }\n    else {\n        $.extend(this, new SAT.Box(new SAT.Vector(x, y), w, h).toPolygon());\n    }\n\n    this.type = type;\n    this.imgReady = false;     // TODO: make private\n\n    if (typeof (src) === \"undefined\" || src === null) {\n        this.w = w;\n        this.h = h;\n    }\n    else {\n        this.w = w; // TODO: fix\n        this.h = h;\n\n        this.img = new Image();\n\n        var that = this;\n        this.img.onload = function () {\n            that.imgReady = true;\n            that.w = this.width;\n            that.h = this.height;\n        };\n        \n        this.img.src = \"img/\" + src;\n    }\n};\n\nGameObj.prototype = {\n    draw: function () {\n        if (this.imgReady) {\n            ctx.drawImage(this.img, this.pos.x, this.pos.y);\n        }\n        else {\n            if(this.type === JQObject.SCALEBG) {\n                ctx.fillStyle = Color.LIGHT_BROWN;\n            }\n            else if(this.type === JQObject.FIREBALL) {\n                ctx.fillStyle = \"orange\";\n            }\n            else {\n                ctx.fillStyle = \"red\";\n            }\n\n            ctx.fillRect(this.pos.x, this.pos.y, this.w, this.h);\n        }\n    }\n};\n",
    "/*\n    GameItem extends GameObj\n    GameItem may extend SAT.Vector to be SAT.Polygon\n\n    @param(GameObj) gObj A game object.\n    @param(?bool) grabbable Whether the game item can be pickup up or not. (false by default)\n    @param(?number) val The value of the game item. (-1 by default)\n    @param(?bool) visible Whether the game item is displayed or not.  (true by default)\n*/\nvar GameItem = function (gObj, grabbable, val, visible) {\n    utils.extend(this, gObj);\n    \n    this.grabbable = (typeof (grabbable) !== \"undefined\") ? grabbable : false;\n    this.val = (typeof(val) !== \"undefined\") ? val : -1;\n    this.visible = (typeof (visible) !== \"undefined\") ? visible : true;\n\n    this.vY = 0;\n    this.isOnObj = false;   // TODO: allow setting to true to avoid \"thud\" sound on level start\n    this.onObj = null;      // contains the object holding up the object (directly below)\n\n    this.isBeingHeld = false;\n\n    // TODO: make private/prototype\n    var parentDraw = this.draw;\n    this.draw = function () {\n        if (this.visible) {\n            parentDraw.apply(this);\n        }\n    };\n};\n\n//GameItem.prototype = {\n//};\n",
    "/// <reference path=\"../linker.js\" />\n\nvar HUD = (function () {\n\n    var cash = null,\n        medKit = null,\n        shuriken = null,\n        syringe = null\n    ;\n\n\n    function drawHealth(){\n        for(var i=0; i < hero.health; ++i){\n            ctx.fillStyle = \"red\";\n            ctx.fillRect(77 + i*21, FULLH + 8, 19, 8);\n        }\n    }\n\t\n    function drawMana(){\n        for(var i=0; i < hero.mana; ++i){\n            ctx.fillStyle = \"#00b6ff\";\n            ctx.fillRect(77 + i*21, FULLH + 26, 19, 8);\n        }\n    }\n\t\n    function drawXP() {\n        ctx.fillStyle = \"#ddd\";\n        ctx.font = \"12px 'Press Start 2P'\";\n        \t\n        var zero = (hero.xp < 10) ? '0' : '';\n        ctx.fillText(zero + hero.xp + '/' + hero.xpNeeded, 77, FULLH + 54);\n    }\n\n\n    return {\n        init: function () {\n            // HUD icons\n            cash = new GameObj(JQObject.EMPTY, 548, FULLH + 20, 22, 24, \"cash.png\");\n            medKit = new GameObj(JQObject.EMPTY, 238, FULLH + 15, 31, 30, \"medKit.png\");\n            shuriken = new GameObj(JQObject.EMPTY, 447, FULLH + 15, 31, 31, \"shuriken.png\");\n            syringe = new GameObj(JQObject.EMPTY, 342, FULLH + 18, 25, 25, \"syringe.png\");\n        },\n\n        draw: function () {// TODO: break out static parts\n            // background\n            ctx.fillStyle = \"#070707\";\n            ctx.fillRect(0, FULLH, FULLW, game.padHUD);\n\n            ctx.fillStyle = \"#ddd\";\n            ctx.font = \"11px 'Press Start 2P'\";\n\n\n            ctx.fillText(\"HP-\" + hero.healthLvl, 7, FULLH + 18);\n            ctx.fillText(\"MP-\" + hero.manaLvl, 7, FULLH + 37);\n            ctx.fillText(\"XP\", 7, FULLH + 54);\n            \n            drawHealth();\n            drawMana();\n            drawXP();\n\n            // hp kit\n            ctx.fillText(hero.medKits, 210, FULLH + 37);\n            medKit.draw();\n\n            // mp kit\n            ctx.fillText(hero.manaKits, 315, FULLH + 37);\n            syringe.draw();\n\n            // ammo\n            ctx.fillText(hero.ammo, 410, FULLH + 37);\n            shuriken.draw();\n\n            // money\n            ctx.fillText(hero.cash, 515, FULLH + 37);\n            cash.draw();\n\n            // lives\n            ctx.fillText(\"LIVES x\" + hero.lives, 700, FULLH + 37);\n\n            // time\n            var time = utils.getTimeObj(game.actualTime);\n            ctx.fillText(time.min + ':' + time.sec, FULLW - 78, FULLH + 24);\n        }\n    };\n})();\n",
    "/// <reference path=\"../linker.js\" />\n\nvar JQEnemy = Object.freeze({\n    STILL: 0,\n    PATROL: 1,\n    FOLLOW: 2\n});\n\n\n/*\n    Enemy extends GameObj\n\n    @param(GameObj) gObj A game object (super class).\n    @param(EnemyType) enemy_t The type of the enemy.\n    @param(number) health The hp of the enemy.\n    @param(number) leftXBound The left x coordinate boundary.\n    @param(number) rightXBound The right x coordinate boundary.\n    @param(bool?) active Is the enemy allowed to move?\n    @constructor\n*/\nvar Enemy = function (gObj, enemy_t, health, leftXBound, rightXBound, active) {\n    utils.extend(this, gObj);\n\n    this.initX = this.pos.x;\n    this.initY = this.pos.y;\n\n    this.initHealth = this.health = health;\n    this.enemy_t = enemy_t;\n    this.leftXBound = leftXBound;\n    this.rightXBound = rightXBound;\n    this.active = (typeof (active) !== \"undefined\") ? active : false;\n    this.deadOffScreen = false;\n\n    // TODO: make private (and initHealth)\n    this.dir = Dir.RIGHT;\n    this.alive = true;\n    this.deadOnScreen = false;\n    this.clearDir = Dir.RIGHT;\n\n    \n    var that = this;\n    \n    // draw\n    function drawHealth() {\n        var healthLen = (that.w / that.initHealth) * that.health;\n\n        ctx.fillStyle = \"red\";\n        ctx.fillRect(that.pos.x, that.pos.y - 12, healthLen, 4);\n    }\n\n    var parentDraw = this.draw;\n    this.draw = function () {\n        if (this.alive || this.deadOnScreen) {\n            if (this.initHealth > 1) {\n                drawHealth();\n            }\n\n            ctx.save();\n            if (this.deadOnScreen) {\n                ctx.globalAlpha = 0.3;\n            }\n\n            parentDraw.apply(this);\n            ctx.restore();\n        }\n    }\n};\n\nEnemy.prototype = {\n\n    update: function () {\n        if (this.deadOnScreen) {\n            if(this.enemy_t === JQEnemy.STILL) {\n                this.deadOnScreen = false;\n                this.deadOffScreen = true;\n            }\n            else {\n                this.pos.x += (this.clearDir === Dir.RIGHT) ? 2 : -2;\n                this.pos.y -= 9;\n\n                if(this.pos.x < 0 || this.pos.x > FULLW) {\n                    this.deadOnScreen = false;\n                    this.deadOffScreen = true;\n                }\n            }\n        }\n        else if (this.active && game.totalTicks % 3 === 0) {\n            this.movement();\n        }\n    },\n\n    // TODO: make private\n    movement: function() {\n        if (this.enemy_t === JQEnemy.PATROL) {\n            if (this.pos.x + hero.lvlX <= this.leftXBound)\n                this.dir = Dir.RIGHT;\n            else if (this.pos.x + hero.lvlX >= this.rightXBound)\n                this.dir = Dir.LEFT;\n\n            if (this.dir === Dir.RIGHT) {\n                ++this.pos.x;\n            }\n            else {\n                --this.pos.x;\n            }\n        }\n        else if (this.enemy_t === JQEnemy.FOLLOW) {\n            if (this.pos.x < hero.pos.x)\n                ++this.pos.x;\n            else if (this.pos.x > hero.pos.x)\n                --this.pos.x;\n        }\n    },\n\n    death: function () {\n        this.clearDir = hero.dir;\n\n        audio.enemyDeath.play();\n        hero.xp += 15;\n        this.alive = false;\n        this.deadOnScreen = true;\n    },\n\n    revive: function() {\n        this.health = this.initHealth;\n        this.deadOffScreen = false;\n        this.deadOnScreen = false;\n        this.alive = true;\n    }\n};",
    "/// <reference path=\"../linker.js\" />\n\nvar level = (function () {\n\n    var maxVy = 10; // applys to GameObj's and GameItem's\n\n\n    /********** Update **********/\n    function updateObjsView() {\n        for (var i = 0; i < level.objs.length; ++i) {\n            level.objs[i].pos.x -= hero.vX;\n\n            if(level.objs[i].type === JQObject.SCALEBG) {\n                level.objs[i].x2 -= hero.vX;\n            }\n\n        }\n    }\n\n    function updateItemsView() {\n        for (var i = 0; i < level.items.length; ++i) {\n            level.items[i].pos.x -= hero.vX;\n        }\n    }\n\n    function updateBgView() {\n        // color layer\n        level.bgColor.gradX -= hero.vX;\n        level.bgColor.fillStyle = Graphics.getDoorBgGrad();\n\n        // objects\n        for (var i = 0; i < level.bg.length; ++i) {\n            var dtX = hero.vX / level.bg[i].speed;\n            level.bg[i].pos.x -= dtX;\n            level.bg[i].distTraveled += dtX;\n        }\n    }\n\n    function updateEnemiesView() {\n        for (var i = 0; i < level.enemies.length; ++i) {\n            level.enemies[i].pos.x -= hero.vX;\n        }\n    }\n\n\n    function updateItems() {\n        for (var i = 0; i < level.items.length; ++i) {\n            if (level.items[i].visible && !level.items[i].isOnObj) {\n                // gravity/position\n                if (level.items[i].vY < maxVy)\n                    level.items[i].vY += game.gravity;\n                else\n                    level.items[i].vY = maxVy;\n\n                // obj collision\n                Physics.testObjObjs(level.items[i], function(r) {\n                    // a is level.items[i]\n                    // b is in level.objs\n\n                    r.a.pos.x -= r.overlapV.x;\n                    r.a.pos.y -= r.overlapV.y;\n\n                    if (r.overlapN.y === 1) {    // on top of platform\n                        audio.thud.play();\n\n                        r.a.vY = (r.b.type === JQObject.ELEVATOR) ? r.b.vY : 0;\n                        r.a.isOnObj = true;\n                        r.a.onObj = r.b;\n                        r.a.recentlyHeld = false;\n\n                        if(r.b.type === JQObject.SCALE && r.b.holdingItem === null) {\n                            r.a.grabbable = false;\n                            r.b.holdingItem = r.a;\n\n                            utils.repeatAction(42, 14, function () {\n                                if(r.b.side === Dir.LEFT) {\n                                    ++r.a.pos.y;\n                                    ++r.b.pos.y;\n\n                                    ++r.b.hBar.pos.y;\n\n                                    --r.b.otherSide.pos.y;\n                                    --r.b.hBar.y2;\n\n                                    if(r.b.otherSide.holdingItem !== null) {\n                                        --r.b.otherSide.holdingItem.pos.y;\n                                        // TODO: chain of crates on top\n                                    }\n                                }\n                                else {\n                                    ++r.a.pos.y;\n                                    ++r.b.pos.y;\n\n                                    ++r.b.hBar.y2;\n\n                                    --r.b.hBar.pos.y;\n                                    --r.b.otherSide.pos.y;\n\n                                    if(r.b.otherSide.holdingItem !== null) {\n                                        --r.b.otherSide.holdingItem.pos.y;\n                                        // TODO: chain of crates on top\n                                    }\n                                }\n\n                            });\n                        }\n                    }\n\n                });\n\n                // item collision\n                Physics.testItemItems(level.items[i], function (r) {\n                    r.a.isOnObj = true;\n                    r.a.onObj = r.b;\n                    r.b.grabbable = false;\n                    r.a.recentlyHeld = false;\n                });\n            }\n\n            if(typeof (level.items[i].onObj) !== \"undefined\" && level.items[i].onObj !== null) {\n                level.items[i].vY = (level.items[i].onObj.type === JQObject.ELEVATOR) ? level.items[i].onObj.vY : 0;\n            }\n\n            level.items[i].pos.y += level.items[i].vY;\n        }\n    }\n\n    function updateEnemies() {\n        for (var i = 0; i < level.enemies.length; ++i) {\n            level.enemies[i].update();\n\n            // TODO: move to hero??\n\n            if(level.enemies[i].health > 0) {\n                // hero and enemy\n                if(SAT.testPolygonPolygon(hero, level.enemies[i])) {\n                    level.enemies[i].active = true;\n\n                    if(!hero.invincible) {\n                        audio.play(audio.heartbeat, true);\n\n                        hero.invincible = true;\n                        --hero.health;\n                    }\n                }\n\n                // projectiles and enemy\n                for (var j = 0; j < hero.bulletArr.length; ++j) {\n                    if(SAT.testPolygonPolygon(hero.bulletArr[j], level.enemies[i])) {\n                        audio.play(audio.thud, true);\n                        level.enemies[i].active = true;\n\n                        hero.bulletArr.splice(j, 1); // remove jth item\n                        --level.enemies[i].health;\n\n                        if (level.enemies[i].health <= 0) {\n                            level.enemies[i].death();\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    /********** Render **********/\n    // the parallax background\n    function drawBg() {\n        // color background\n        ctx.fillStyle = \"#000\";\n        ctx.fillRect(0, FULLH - game.padFloor, FULLW, game.padFloor);\n        ctx.fillStyle = level.bgColor.fillStyle;\n        ctx.fillRect(0, 0, FULLW, FULLH - game.padFloor);\n\n        // background objects\n        for (var i = 0; i < level.bg.length; ++i) {\n            //level.bg[i].draw();\n            var t = level.bg[i];\n            var scale = utils.speed2scale(t.speed);\n\n            ctx.drawImage(t.img, t.pos.x, t.pos.y, t.w * scale, t.h * scale);\n        }\n    }\n\n    // all of the collision rectangles in the level\n    function drawObjs() {\n        for (var i = 0; i < level.objs.length; ++i) {\n            var obj = level.objs[i];\n\n            // check if visible; TODO: all objs should have visible property (fix api)\n            if (typeof (obj.visible) !== \"undefined\" && !obj.visible) {\n                continue;\n            }\n            \n\n            if(obj.type === JQObject.LADDER) {           // ladder\n                Graphics.drawLadder(obj);\n            }\n            else if(obj.type === JQObject.SCALE) {       // scale\n                Graphics.drawScale(obj);\n                Graphics.drawPlatformStatus(obj);\n            }\n            else if(obj.type === JQObject.PLATFORM || obj.type === JQObject.SLOPE || obj.type === JQObject.ELEVATOR) {\n                Graphics.drawPlatform(obj);\n            }\n            else if(obj.type === JQObject.DOOR) {\n                Graphics.drawDoor(obj);\n            }\n            else if(obj.type === JQObject.POLY) {\n                Graphics.drawPoly(obj);\n            }\n            else if(obj.type === JQObject.HILL) {\n                Graphics.drawHill(obj);\n            }\n            else {\n                obj.draw();\n            }\n        }\n    }\n\n    function drawItems() {\n        for (var i = 0; i < level.items.length; ++i) {\n            level.items[i].draw();\n        }\n    }\n\n    function drawEnemies() {\n        for (var i = 0; i < level.enemies.length; ++i) {\n            if (!level.enemies[i].deadOffScreen) {\n                level.enemies[i].draw();\n            }\n        }\n    }\n\n\n    return {\n        bgColor: {},\n        bg: [],             // dynamically holds all of the background objects for the level\n        objs: [],           // dynamically holds all of the objects for the level\n        items: [],          // dynamically holds all of the items for the level\n        enemies: [],        // dynamically holds all of the enemies for the level\n        curLvl: null,       // alias for the current level object e.g. lvl1\n        isCutscene: false,\n        time: 0,\n        hiddenItemsFound: 0,\n        hiddenItems: 0,\n        isTransitioning: false,\n        \n\n        init: function() {\n            level.reset();\n            level.curLvl = new StartScreen();     // level '0'\n        },\n\n        // called before start of level\n        reset: function () {\n            // reset game stats\n            game.over = false;\n            game.actualTime = 0;\n\n            // reset level\n            level.hiddenItemsFound = 0;\n            hero.lvlX = 0;\n            level.bgColor = {\n                fillStyle: \"#000\"\n            };\n            level.bg = [];\n            level.objs = [];\n            level.items = [];\n            level.enemies = [];\n\n            // reset hero\n            hero.pos.x = 23;\n            hero.pos.y = FULLH - game.padFloor - hero.h + 4;    // TODO: find out '4' offset??\n            hero.vX = hero.vY = 0;\n            hero.isJumping = false;\n            hero.ammo = 20;\n            hero.bulletArr.length = 0;\t\t// prevents leftover thrown shurikens\n            hero.invincible = false;\n            hero.isHolding = false;\n            hero.curItem = null;\n            hero.dir = Dir.RIGHT;\n            hero.health = hero.maxHealth;\n        },\n\n        // called at end of level\n        complete: function () {\n            level.isTransitioning = true;\n            audio.lvlComplete();\n\n            // reset graphics timers (to fix blink text)\n            Graphics.ticker = 1;\n            Graphics.fadeOut = true;\n\n            Graphics.fadeCanvas(function () {\n                level.isTransitioning = false;\n                level.curLvl = lvlComplete;\n                level.isCutscene = true;\n                level.time = game.actualTime;\n\n                // TODO: audio.lvlCompleted.play()\n            });\n        },\n\n        /******************** Update ********************/\n        update: function () {\n            if (!level.isTransitioning) {\n                if (game.lvl != 0) {\n                    updateItems();\n                    updateEnemies();\n\n                    // bg objects\n                    var i = level.bg.length;\n                    while (i--) {\n                        var dtX = 0.5 / level.bg[i].speed;\n                        level.bg[i].pos.x -= dtX;\n                        level.bg[i].distTraveled += dtX;\n\n                        if (level.bg[i].distTraveled > level.bg[i].distToTravel) {\n                            level.bg.splice(i, 1);\n                            Graphics.spawnCloud(level.curLvl.width);\n                        }\n                    }\n                }\n\n                level.curLvl.update();\n            }\n        },\n\n        // fix positions relative to the \"camera\" view\n        updateView: function(){\n            updateObjsView();\n            updateItemsView();\n            updateBgView();\n            updateEnemiesView();\n        },\n\n\n        /******************** Render ********************/\n        render: function () {\n            drawBg();\n            drawObjs();\n            drawItems();\n            drawEnemies();\n            \n            level.curLvl.render();\n        }\n    };\n})();\n",
    "/// <reference path=\"../linker.js\" />\r\n\r\nvar lvlComplete = (function () {\r\n\r\n    function complete(debugLvl) {\r\n        lastKeyDown = KeyCode.EMPTY;\r\n        level.reset();\r\n\r\n        if (debugLvl != null) {\r\n            game.lvl = debugLvl;\r\n        }\r\n        else {\r\n            ++game.lvl;\r\n        }\r\n\r\n        switchLevel(game.lvl);\r\n        level.isCutscene = false;\r\n    }\r\n\r\n    function switchLevel(lvl) {\r\n        switch (lvl) {\r\n            case 1:\r\n                lvl1.init();\r\n                level.curLvl = lvl1;\r\n                break;\r\n            case 2:\r\n                lvl2.init();\r\n                level.curLvl = lvl2;\r\n                break;\r\n            case 3:\r\n                var lvl3 = new Level3();\r\n                level.curLvl = lvl3;\r\n        }\r\n\r\n        audio.updateBgMusic();\r\n    }\r\n\r\n    return {\r\n        update: function () {\r\n            if (window.DEBUG) {\r\n                complete(window.DEBUG_OPT['lvl']);\r\n            }\r\n            else if (keysDown[KeyCode.ENTER] || game.lvl === 0) {\r\n                complete();\r\n            }\r\n        },\r\n\r\n        render: function () {\r\n            // background\r\n            ctx.fillStyle = \"#000\";\r\n            ctx.fillRect(0, 0, FULLW, canvas.height);\r\n\r\n            // title\r\n            ctx.font = \"24px 'Press Start 2P'\";\r\n            var title = \"LEVEL \" + game.lvl + \" COMPLETE\";\r\n            var titleW = ctx.measureText(title).width;\r\n            ctx.fillStyle = Color.ORANGE;\r\n            ctx.fillText(title, HALFW - titleW/2, 70);\r\n            \r\n            // level time\r\n            ctx.font = \"18px 'Press Start 2P'\";\r\n            var time = utils.getTimeObj(level.time);\r\n            var timeTxt = \"LEVEL TIME......\" + time.min + ':' + time.sec;\r\n            var timeW = ctx.measureText(timeTxt).width;\r\n            ctx.fillStyle = \"#e1e1e1\";\r\n            ctx.fillText(timeTxt, HALFW - titleW / 2, 150);\r\n\r\n            // hidden items\r\n            ctx.font = \"18px 'Press Start 2P'\";\r\n            var hdnItems = \"HIDDEN ITEMS.....\" + level.hiddenItemsFound + '/' + level.hiddenItems;\r\n            var hdnItemsW = ctx.measureText(hdnItems).width;\r\n            ctx.fillStyle = \"#e1e1e1\";\r\n            ctx.fillText(hdnItems, HALFW - hdnItemsW / 2, 190);\r\n\r\n            // cta\r\n            Graphics.blinkText(16, HALFW, HALFH + 120);\r\n        }\r\n    };\r\n})();\r\n",
    "/// <reference path=\"../linker.js\" />\n\n// level '0'\nfunction StartScreen() {\n    this.width = FULLW;\n\n    level.isCutscene = true;\n}\n\nStartScreen.prototype = (function() {\n    var copyTitle1 = \"JON'S\",\n        copyTitle2 = \"QUEST\",\n        copyLine = String.fromCharCode(\"169\") + \" 2014 JON WIEDMANN\"\n    ;\n\n    return {\n        update: function(){\n            if (lastKeyDown === KeyCode.ENTER) {\n                level.complete();\n            }\n        },\n\n        render: function(){\n            //---- title\n\n            // title 1\n            ctx.font = \"29px 'Press Start 2P'\";\n            var startX = HALFW - ctx.measureText(copyTitle1).width / 2 + 11,\n                startY = 58;\n\n            ctx.setTransform(1, 0, -0.4, 1.4, 0, 0);\n            ctx.fillStyle = \"#222\";\n            ctx.fillText('J', startX + 4, startY + 3);\n            ctx.fillStyle = \"#ff6a00\";\n            ctx.fillText('J', startX, startY);\n            ctx.setTransform(1, 0, -0.2, 1.4, 0, 0);\n            ctx.fillStyle = \"#222\";\n            ctx.fillText('O', startX + 32, startY + 3);\n            ctx.fillStyle = \"#ff6a00\";\n            ctx.fillText('O', startX + 28, startY);\n            ctx.setTransform(1, 0, 0.05, 1.41, 0, -1);\n            ctx.fillStyle = \"#222\";\n            ctx.fillText('N', startX + 58, startY + 3);\n            ctx.fillStyle = \"#ff6a00\";\n            ctx.fillText('N', startX + 54, startY);\n            ctx.setTransform(1, 0, 0.23, 1.4, 0, 0);\n            ctx.fillStyle = \"#222\";\n            ctx.fillText(\"'\", startX + 78, startY + 3);\n            ctx.fillStyle = \"#ff6a00\";\n            ctx.fillText(\"'\", startX + 74, startY);\n            ctx.setTransform(1, 0, 0.42, 1.4, 0, 0);\n            ctx.fillStyle = \"#222\";\n            ctx.fillText('S', startX + 95, startY + 3);\n            ctx.fillStyle = \"#ff6a00\";\n            ctx.fillText('S', startX + 91, startY);\n\n\n            // title 2\n            ctx.font = \"36px 'Press Start 2P'\";\n            startX = HALFW - ctx.measureText(copyTitle2).width / 2 + 30;\n            startY = 98;\n\n            ctx.setTransform(1, 0, -0.5, 1.6, 0, 0);\n            ctx.fillStyle = \"#222\";\n            ctx.fillText('Q', startX + 4, startY + 3);\n            ctx.fillStyle = \"#ff6a00\";\n            ctx.fillText('Q', startX, startY);\n            ctx.setTransform(1, 0, -0.25, 1.6, 0, 0);\n            ctx.fillStyle = \"#222\";\n            ctx.fillText('U', startX + 26, startY + 3);\n            ctx.fillStyle = \"#ff6a00\";\n            ctx.fillText('U', startX + 22, startY);\n            ctx.setTransform(1, 0, 0.03, 1.6, 0, 0);\n            ctx.fillStyle = \"#222\";\n            ctx.fillText('E', startX + 50, startY + 3);\n            ctx.fillStyle = \"#ff6a00\";\n            ctx.fillText('E', startX + 46, startY);\n            ctx.setTransform(1, 0, 0.25, 1.6, 0, 0);\n            ctx.fillStyle = \"#222\";\n            ctx.fillText('S', startX + 74, startY + 3);\n            ctx.fillStyle = \"#ff6a00\";\n            ctx.fillText('S', startX + 70, startY);\n            ctx.setTransform(1, 0, 0.5, 1.6, 0, 0);\n            ctx.fillStyle = \"#222\";\n            ctx.fillText('T', startX + 90, startY + 4);\n            ctx.fillStyle = \"#ff6a00\";\n            ctx.fillText('T', startX + 86, startY);\n            ctx.setTransform(1, 0, 0, 1, 0, 0);\t// reset\n\n            //---- press enter\n            Graphics.blinkText(22, HALFW, HALFH + 81);\n\n            //---- copyright\n            ctx.fillStyle = \"#000\";\n            ctx.fillRect(0, FULLH, FULLW, game.padHUD);\n            ctx.font = \"13px 'Press Start 2P'\";\n            ctx.fillStyle = \"#c9c9c9\";\n\n            ctx.fillText(copyLine, HALFW - ctx.measureText(copyLine).width / 2, FULLH + 24);\n        }\n    };\n})();\n",
    "/// <reference path=\"../linker.js\" />\r\n\r\nvar lvl1 = (function () {\r\n\r\n    var hiddenCash,\r\n\t\tdoor,\r\n        ladder,\r\n        doLadder = false,\r\n        theScale = {}\r\n    ;\r\n\r\n    function setBackground() {\r\n        // color layer\r\n        level.bgColor.gradX = door.pos.x + door.w/2;\r\n        level.bgColor.gradY = door.pos.y + door.h / 2;\r\n        level.bgColor.c0 = \"rgb(203,163,0)\";\r\n        level.bgColor.c1 = \"#1F7DCF\";\r\n        level.bgColor.fillStyle = Graphics.getDoorBgGrad();\r\n\r\n        // objects\r\n        Graphics.setClouds(lvl1.width);\r\n    }\r\n\r\n    function setObjs() {\r\n        // floor + 3 initial platforms\r\n        level.objs.push(\r\n            new GameObj(JQObject.PLATFORM, -Graphics.projectX, FULLH - game.padFloor - 1, lvl1.width + Graphics.projectX * 2, game.padFloor + 1),\r\n            new GameObj(JQObject.PLATFORM, 200, 206, 267, 62),\r\n            new GameObj(JQObject.PLATFORM, 575, 310, 300, 62),\r\n            new GameObj(JQObject.PLATFORM, 605, 125, 220, 62)\r\n        );\r\n\r\n        // scales\r\n        theScale = Graphics.getScale(1500, FULLH - game.padFloor - 137);\r\n        level.objs.push(theScale.vBar, theScale.hBar, theScale[Dir.LEFT], theScale[Dir.RIGHT]);\r\n\r\n\r\n        // stairs, platform, and door\r\n        var stairs = new GameObj(JQObject.SLOPE, 2203, 208, 252, 62, null, Dir.UP_RIGHT);\r\n        var doorPlat = new GameObj(JQObject.PLATFORM, stairs.pos.x + stairs.w - 11, stairs.pos.y - stairs.h - 5, 200, 62);\r\n        door = new GameObj(JQObject.DOOR, doorPlat.pos.x + doorPlat.w - 63, doorPlat.pos.y - 62 - Graphics.projectY / 2, 33, 62);\r\n        level.objs.push(doorPlat, stairs, door);\r\n\r\n        // TODO: move to setItems() ??\r\n        ladder = new GameItem(new GameObj(JQObject.LADDER, stairs.pos.x - 37, stairs.pos.y - 1, 38, FULLH - stairs.pos.y - game.padFloor), false, 0, false);\r\n        ladder.collidable = false;      // allows ladder to not be in normal collision detection\r\n        level.objs.push(ladder);\r\n    }\r\n\r\n    function setItems() {\r\n        // crates\r\n        var crate = [];\r\n        for (var i = 0; i < 3; ++i) {\r\n            crate.push(\r\n                new GameItem(\r\n                    new GameObj(JQObject.CRATE, 446, FULLH - game.padFloor - 26 + 5, 34, 37, \"crate.png\"),\r\n                    true\r\n                )\r\n            );\r\n        }\r\n        crate[1].pos.x = theScale[Dir.LEFT].pos.x + theScale[Dir.LEFT].w / 2 - crate[0].w / 2;\r\n        crate[2].pos.x = theScale[Dir.RIGHT].pos.x + theScale[Dir.RIGHT].w / 2 - crate[0].w / 2;\r\n\r\n        // sack\r\n        var sack = new GameItem(new GameObj(JQObject.SACK, 680, 111 + Graphics.projectY / 2, 30, 34, \"sack.png\"), false, 5);\r\n\r\n        // hidden cash; TODO: only add to level.items after visible???\r\n        hiddenCash = new GameItem(new GameObj(JQObject.CASH, 113, 80, 22, 24, \"cash.png\"), false, 10, false);\r\n\r\n        level.items.push(crate[0], crate[1], crate[2], sack, hiddenCash);\r\n    }\r\n\r\n    function setEnemies() {\r\n        var cyborg = new Enemy(\r\n            new GameObj(JQObject.ENEMY, 1200, FULLH - game.padFloor - 55 + Graphics.projectY/2, 40, 55, \"cyborgBnW.png\"),\r\n            JQEnemy.FOLLOW,\r\n            1,\r\n            1087,\r\n            1600,\r\n            false\r\n        );\r\n        cyborg.collidable = false;  // TODO: fix api\r\n        level.enemies.push(cyborg);\r\n    }\r\n\r\n\r\n    return {\r\n        width: 2710,\r\n\r\n\r\n        init: function () {\r\n            level.hiddenItems = 1;\r\n\r\n            setObjs();\r\n            setItems();\r\n            setEnemies();\r\n            \r\n            setBackground();\r\n        },\r\n\r\n        deinit: function(){\r\n            hiddenCash = null;\r\n            door = null;\r\n            ladder = null;\r\n            doLadder = false;\r\n        },\r\n\r\n        update: function () {\r\n            if(doLadder) {\r\n                hero.onLadder = SAT.testPolygonPolygon(hero, ladder);\r\n            }\r\n            else {\r\n                doLadder = Physics.handleScale();\r\n            }\r\n\r\n            // hidden cash\r\n            if (!hiddenCash.visible) {\r\n                for (var i = 0; i < hero.bulletArr.length; ++i) {\r\n                    if (Physics.isCollision(hero.bulletArr[i], hiddenCash, -17)) {\r\n                        hiddenCash.visible = true;\r\n                        audio.discovery.play();\r\n                        ++level.hiddenItemsFound;\r\n                    }\r\n                }\r\n            }\r\n\r\n            // door\r\n            if (!game.over && Physics.isCollision(hero, door, 0)) {     // TODO: why checking game.over???\r\n                level.complete();\r\n            }\r\n        },\r\n\r\n        render: function() {\r\n            Graphics.drawScaleBg(theScale);\r\n        }\r\n    };\r\n\r\n})();\r\n",
    "/// <reference path=\"../linker.js\" />\n\nvar lvl2 = (function () {\n\n    var floor1,\n        hill,\n        floorPlat,\n        colL,\n        colR,\n        bridge,\n        elevator = [],\n        wall,\n        slope,\n        ladder,\n        door,\n        enemy2hotspot,\n        enemy2,\n        fireball = null,\n        theScale = {},\n        doRevive = false,\n        doLadder = false\n    ;\n\n\n    function setBackground() {\n        level.bgColor.gradX = door.pos.x;\n        level.bgColor.gradY = door.pos.y;\n        level.bgColor.c0 = \"rgb(203,163,0)\";\r\n        level.bgColor.c1 = \"#1F7DCF\";\n        level.bgColor.fillStyle = Graphics.getDoorBgGrad();\n\n        Graphics.setClouds(lvl2.width);\n    }\n\n    function setObjs() {\n        floor1 = new GameObj(JQObject.PLATFORM, -Graphics.projectX, FULLH - game.padFloor, FULLW - 250, game.padFloor);\n        hill = new GameObj(JQObject.HILL, 200, FULLH - game.padFloor, 320, 60);\n        floorPlat = new GameObj(JQObject.PLATFORM, floor1.pos.x + floor1.w - Graphics.projectX, floor1.pos.y - floor1.h - 30, 1000, 180);\n        colL = new GameObj(JQObject.PLATFORM, floorPlat.pos.x + 240, floorPlat.pos.y - 90 + Graphics.projectY, 100, 85);\n        colR = new GameObj(JQObject.PLATFORM, floorPlat.pos.x + floorPlat.w - 100, floorPlat.pos.y - 90 + Graphics.projectY, 100, 85);\n        bridge = new GameObj(JQObject.PLATFORM, colL.pos.x + 140, colL.pos.y - 137, 480, 30);\n\n        level.objs.push(floorPlat, floor1, hill,colL, colR, bridge);\n\n        // elevators\n        for(var i = 0; i < 3; ++i) {\n            elevator[i] = new GameObj(JQObject.ELEVATOR, colR.pos.x + 237 + i * 300, colR.pos.y - i*80, 115, 26);\n            elevator[i].dir = Dir.DOWN;\n            level.objs.push(elevator[i]);\n        }\n\n        wall = new GameObj(JQObject.PLATFORM, elevator[2].pos.x + elevator[2].w + 120, 190, 100, FULLH - 190);\n        slope = new GameObj(JQObject.SLOPE, wall.pos.x + wall.w - Graphics.projectX, wall.pos.y, 900, FULLH - 190, null, Dir.DOWN_RIGHT);\n        \n        var platty = new GameObj(JQObject.PLATFORM, slope.pos.x + slope.w - Graphics.projectX - 1, FULLH - game.padFloor, 1000, game.padFloor);\n\n        theScale = Graphics.getScale(platty.pos.x + 250, FULLH - game.padFloor - 137);\n        level.objs.push(theScale.hBar, theScale.vBar, theScale[Dir.LEFT], theScale[Dir.RIGHT]);\n\n        ladder = new GameObj(JQObject.LADDER, platty.pos.x + platty.w - Graphics.projectX - 30, 140, 30, FULLH - 140 - game.padFloor);\n        ladder.visible = false;\n        ladder.collidable = false;\n\n        var platty2 = new GameObj(JQObject.PLATFORM, ladder.pos.x + ladder.w, 140, 350, game.padFloor);\n\n        door = new GameObj(JQObject.DOOR, platty2.pos.x + platty2.w - 90, platty2.pos.y - 100, 40, 100);\n\n        level.objs.push(platty, slope, wall, platty2, door, ladder);\n    }\n\n    function setItems() {\n        var crate = new GameItem(new GameObj(JQObject.CRATE, bridge.pos.x + bridge.w / 2 - 80, bridge.pos.y - 37, 34, 37, \"crate.png\"), true);\n        var crate2 = new GameItem(new GameObj(JQObject.CRATE, bridge.pos.x + bridge.w / 2 + 80, bridge.pos.y - 37, 34, 37, \"crate.png\"), true);\n                    \n        var sack = new GameItem(\n            new GameObj(JQObject.SACK, colL.pos.x + 300, 302, 30, 36, \"sack.png\"),\n            true,\n            5\n        );\n\n        level.items.push(sack, crate, crate2);\n    }\n\n    function setEnemies() {\n        var enemy = new Enemy(\n            new GameObj(JQObject.ENEMY, colL.pos.x + colL.w, 404, 40, 55, \"cyborgBnW.png\"),\n            JQEnemy.PATROL,\n            1,\n            colL.pos.x + colL.w,\n            colR.pos.x - 55/2,\n            true\n        );\n        enemy.collidable = true;        // TODO: fix api\n        level.enemies.push(enemy);\n\n        enemy2 = getEnemy2();\n\n        enemy2hotspot = new GameObj(JQObject.EMPTY, enemy2.pos.x, enemy2.pos.y, enemy2.w, enemy2.h);\n        enemy2hotspot.collidable = false;\n        enemy2hotspot.visible = false;\n        level.objs.push(enemy2hotspot);\n\n        level.enemies.push(enemy2);\n    }\n\n    function getEnemy2() {\n        en = new Enemy(\n            new GameObj(JQObject.ENEMY, wall.pos.x + 35, wall.pos.y - 55, 40, 55, \"cyborgBnW.png\"),\n            //new GameObj(JQObject.ENEMY, 135, FULLH - game.padFloor - 55, 40, 55, \"cyborgBnW.png\"),\n            JQEnemy.STILL,\n            5\n        );\n        en.collidable = true;\n\n        return en;\n    }\n\n    function handleFireball() {\n        // enemy2hotspot\n        if((enemy2hotspot.pos.x + enemy2hotspot.w) >= 0 && (enemy2hotspot.pos.x + enemy2hotspot.w) <= FULLW) {\n            // revive enemy2\n            if(doRevive) {\n                doRevive = false;\n                enemy2.revive();\n            }\n\n            // shoot fireball\n            if(enemy2.alive && fireball === null) {\n                var dir;\n                \n                if(hero.pos.x < enemy2.pos.x)\n                    dir = Dir.LEFT;\n                else\n                    dir = Dir.RIGHT\n\n                fireball = new GameObj(JQObject.FIREBALL, enemy2.pos.x, enemy2.pos.y, 20, 20, null, dir);\n                fireball.tag = level.objs.length;\n                fireball.collidable = false;\n                level.objs.push(fireball);\n            }\n        }\n        else if(!enemy2.alive){\n            doRevive = true;\n        }\n\n        // update position\n        if(fireball !== null) {\n            if(fireball.dir === Dir.LEFT) {\n                --fireball.pos.x;\n            }\n            else {\n                ++fireball.pos.x;\n            }\n\n            if(fireball.pos.x <= 0 || fireball.pos.x >= FULLW) {\n                level.objs.splice(fireball.tag, 1);\n                fireball = null;\n            }\n        }\n\n        // test collision\n        if(!hero.invincible && fireball !== null && SAT.testPolygonPolygon(hero, fireball)) {\n            level.objs.splice(fireball.tag, 1);\n            fireball = null;\n            audio.play(audio.heartbeat, true);\n\n            hero.invincible = true;\n            --hero.health;\n        }\n    }\n\n    return {\n        width: 5030,\n\n\n        init: function () {\n            level.hiddenItems = 0;\n\n            setObjs();\n            setItems();\n            setEnemies();\n\n            setBackground();\n        },\n\n        deinit: function(){\n            doLadder = false;\n        },\n\n        update: function() {\n            // elevators\n            for(var i = 0; i < elevator.length; ++i) {\n                if(elevator[i].dir === Dir.UP && elevator[i].pos.y < 100) {\n                    elevator[i].dir = Dir.DOWN;\n                }\n                else if(elevator[i].dir === Dir.DOWN && elevator[i].pos.y > 400) {\n                    elevator[i].dir = Dir.UP;\n                }\n\n                elevator[i].vY = (elevator[i].dir === Dir.DOWN) ? 1 : -1;   // used by hero\n                elevator[i].pos.y += elevator[i].vY;\n            }\n            \n            // fireball\n            handleFireball();\n\n            // ladder\n            if(doLadder) {\n                hero.onLadder = SAT.testPolygonPolygon(hero, ladder);\n            }\n            else {\n                doLadder = Physics.handleScale();\n            }\n\n            // door\n            if(SAT.testPolygonPolygon(hero, door)) {\n                level.complete();\n            }\n        },\n\n        render: function() {\n            Graphics.drawScaleBg(theScale);\n        }\n    };\n})();",
    "/// <reference path=\"../linker.js\" />\n\nfunction Level3() {\n    this.init();\n}\n\nLevel3.prototype = (function() {\n\n    var boss;\n\n    function setBackground() {\r\n        // color layer\r\n        level.bgColor.gradX = 1400;\r\n        level.bgColor.gradY = 180;\r\n        level.bgColor.c0 = \"#222\";\r\n        level.bgColor.c1 = \"#333\";\r\n\r\n        var grad = ctx.createRadialGradient(\n            level.bgColor.gradX,\n            level.bgColor.gradY,\n            14,\n            level.bgColor.gradX,\n            level.bgColor.gradY,\n            440\n        );\r\n\r\n        grad.addColorStop(0, level.bgColor.c0);\n        grad.addColorStop(1, level.bgColor.c1);\r\n        level.bgColor.fillStyle = grad;\r\n\r\n        // objects\r\n        Graphics.setClouds(Level3.prototype.width);\r\n    }\n\n    function setObjects(){\n        var floor = new GameObj(JQObject.PLATFORM, -Graphics.projectX, FULLH - game.padFloor, 1050, game.padFloor);\n        level.objs.push(floor);\n    }\n\n    function setEnemies(){\r\n        boss = new Enemy(\n            new GameObj(JQObject.ENEMY, 400, FULLH - game.padFloor - 160, 120, 165, \"cyborgBnW_boss.png\"),\n            JQEnemy.PATROL,\n            1,\n            200,\n            500,\n            true\n        );\n\n        boss.collidable = true;        // TODO: fix api\n        level.enemies.push(boss);\r\n    }\n\n    return {\n        width: 1008,\n\n\n        init: function() {\n            level.hiddenItems = 0;\n            setObjects();\n            //setItems();\n            setEnemies();\n\n            setBackground();\n        },\n\n        deinit: function() {\n\n        },\n\n        update: function() {\n\n        },\n\n        render: function() {\n            ctx.fillStyle = \"#fff\";\n            ctx.font = \"22px 'Press Start 2P'\";\n            ctx.fillText(\"LEVEL 3 -- BOSS BATTLE COMING SOON!!\", 150, 280);\n        }\n    };\n})();\n",
    "/// <reference path=\"../linker.js\" />\n\nvar game = (function () {\n\tvar\tavgFPS = 0,\n\t\trenderTimePrev = 0,\n\t\trenderTimeBtw = 16,\n\t\tfpsHistory = [60],\n\t\tupdateFpsHistory = [120],\n\t\tupdateTimePrev = 0,\n\t\tupdateTimeBtw = 8,\n\t\t//lag = 0,\n\t\trenderLoop,\n\t\tupdateLoop\n\t;\n\t\n\tfunction update() {\n//\t    var updateTimeCur = new Date().getTime();\n\n//\t    // timers\n//\t    if((updateTimeCur - updateTimePrev) > 0) {\n//\t        updateTimeBtw = updateTimeCur - updateTimePrev;\n////\t        console.log(updateTimeBtw);\n//\t    }\n//\t    updateTimePrev = updateTimeCur;\n\n\n\t\tif (!level.isCutscene && !level.isTransitioning && !game.over) {\n\t\t\thero.update();\n\t\t}\n\n\t\tlevel.update();\n\t}\n\t\n\tfunction render(renderTimeCur) {\n\t\t// timers\n\t\tif ((renderTimeCur - renderTimePrev) > 0) {\n\t\t\trenderTimeBtw = renderTimeCur - renderTimePrev;\n\t\t}\n\t\trenderTimePrev = renderTimeCur;\n\n\t\trenderLoop = requestAnimationFrame(render);\n\t\t\n\t\t// drawing\n\t\tlevel.render();\n\n\t\tif (!level.isCutscene) {\n\t\t\tif(!game.over)\n\t\t\t\thero.render();\n\n\t\t\tHUD.draw();\n\t\t\tdrawFPS();\n\t\t}\n\t}\n\t\n\tfunction drawFPS(fps) {\n\t\tfpsHistory.push(1000 / renderTimeBtw);\n\t\t\n\t\tif (game.totalTicks % 120 === 0) {\n\t\t\tvar tot = 0,\n\t\t\t\ti = fpsHistory.length\n\t\t\t;\n\t\t\t\n\t\t\twhile (--i) {\n\t\t\t\ttot += fpsHistory[i];\n\t\t\t}\n\t\t\t\n\t\t\tif (fpsHistory.length > 0) {\n\t\t\t\tavgFPS = Math.floor(tot / fpsHistory.length);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tavgFPS = 0;\n\t\t\t}\n\n\t\t\twhile (fpsHistory.length > 0) {\n\t\t\t\tfpsHistory.pop();\n\t\t\t}\n\t\t}\n\t\t\n\t\tctx.fillStyle = \"#ddd\";\n\t\tctx.font = \"11px 'Press Start 2P'\";\n\t\tctx.fillText(avgFPS + \" FPS\", FULLW - 77, FULLH + 50);\n\t}\n\t\n\n\treturn {\n\t\tover: false,        // indicates the game is finished\n\t\tgravity: 0.13,\n\t\tpadHUD: 58,\n\t\tpadFloor: 16,\n\t\tlvl: 0,\n\t\ttotalTicks: 0,      // ticks are update iterations\n\t\tactualTime: 0,\n\n\n\t\tstart: function () {\n\t\t\t// update at fixed time interval\n\t\t\tupdateLoop = setInterval(function () {\n\t\t\t\t++game.totalTicks;\n\t\t\t\tGraphics.ticker += Graphics.fadeOut ? -Graphics.tickerStep : Graphics.tickerStep;\n\n\t\t\t\t//var updateTimeCur = new Date().getTime();\n\n\t\t\t\t//if ((updateTimeCur - updateTimePrev) > 0) {\n\t\t\t\t//game.updateTimeBtw = updateTimeCur - updateTimePrev;\n\t\t\t\t//}\n\n\t\t\t\t//updateTimePrev = updateTimeCur;\n\t\t\t\t//lag += game.updateTimeBtw;\n\n\t\t\t\t//while (lag >= game.updateTimeBtw) {      // TODO: interpolate if needed\n\t\t\t\tupdate();\n\t\t\t\t//lag -= game.updateTimeBtw;\n\t\t\t\t//}\n\t\t\t}, 8.3333); // 1000 / 120 ==> 2x target rate of 60fps\n\t\t\t\n\t\t\t// render w/vsync (let browser decide)\n\t\t\trender();\n\t\t},\n\n\t\tstop: function () {\n\t\t\twindow.cancelAnimationFrame(renderLoop);\n\t\t\tclearInterval(updateLoop);\n\t\t}\n\t};\n})();\n",
    "/// <reference path=\"../linker.js\" />\n\nvar Shuriken = {\n    w: 31,\n    h: 31,\n    speed: 4.4\n};\n\n// The hero object.  TODO: convert to be of GameObj type\nvar hero = (function () {\n    var input = null,           // the hero input component\n        graphics = null,        // the hero graphics component\n        physics = null,         // the hero physics component\n        imgReady = false,\n\t\timg = null,\n\t\tspriteArr = [],\n\t\tinvincibleTimer = 170,\n        invincibleTimer0 = 170\n\t;\n\t\n\t\t\n\t/*********************** Update ***********************/\n    function checkHealth() {\n        if (hero.invincible)\n            --invincibleTimer;\n\n        if (invincibleTimer <= 0) {\n            hero.invincible = false;\n            invincibleTimer = invincibleTimer0;\n        }\n        \n        if (hero.health <= 0 && !game.over) {\n            utils.deathSequence();\n        }\n    }\n\n    function getSpritePos() {\n\t\tvar pos = {x: 0, y: 0};\n\t\t\n\t\tif (hero.isHolding && hero.vX === 0) {\n\t\t\tpos = spriteArr[\"playerDown\"];\n\t\t}\n\t\telse if (hero.onLadder) {               // TODO: check if holding crate (shouldn't be allowed on ladder)\n\t\t    pos = spriteArr[\"playerUp\"];\n\t\t}\n\t\telse if (hero.dir === Dir.RIGHT || hero.dir === Dir.LEFT) {\n\t\t    var dirR = (hero.dir === Dir.RIGHT);\n\t\t    var theDir = \"player\" + (dirR ? \"Right\" : \"Left\");\n\n\t\t    if (dirR && hero.vX > 0 ||  // right\n\t\t        !dirR && hero.vX < 0    // left\n            ) {\n\t\t        var runTimer = (game.totalTicks % 96);\n\n\t\t        if(!hero.isOnObj){\n\t\t            pos = spriteArr[theDir + \"_Run1\"];\n\t\t        }\n                else if(Math.abs(hero.vX) <= hero.aX*10){\n\t\t            pos = spriteArr[theDir + \"_Step\"];\n\t\t        }\n\t\t        else if(runTimer >= 0 && runTimer < 24) {\n\t\t            pos = spriteArr[theDir + \"_Run1\"];\n\n\t\t            if(!hero.isJumping) {\n\t\t                audio.step.play();\n\t\t            }\n\t\t        }\n\t\t        else if (runTimer >= 24 && runTimer < 48) {\n\t\t            pos = spriteArr[theDir + \"_Run2\"];\n\t\t        }\n\t\t        else if(runTimer >= 48 && runTimer < 72){\n\t\t            pos = spriteArr[theDir + \"_Run3\"];\n\n\t\t            if(!hero.isJumping) {\n\t\t                audio.step.play();\n\t\t            }\n\t\t        }\n\t\t        else {\n\t\t            pos = spriteArr[theDir + \"_Run2\"];\n\t\t        }\n\t\t\t}\n\t\t\telse\n\t\t\t\tpos = spriteArr[theDir];\n\t\t}\n\t\t\n        // idle animation\n\t\tif(!hero.onLadder && hero.vX === 0 && hero.vY === 0) {\n\t\t    ++hero.idleTime;\n\t\t}\n\t\telse {\n\t\t    hero.idleTime = 0;\n\n\t\t    if (hero.isHolding) {\n\t\t        hero.curItem.pos.y = hero.pos.y + 20;\n\t\t    }\n\t\t}\n\n\t\tif (hero.idleTime > 210) {\n\t\t    var foo = hero.idleTime % 200;\n\t\t    \n\t\t    if (foo >= 0 && foo <= 50 || foo > 100 && foo <= 150)\n\t\t        pos = spriteArr[\"playerDown\"];\n\t\t    else if (foo > 50 && foo <= 100) {\n\t\t        pos = spriteArr[\"playerDown_breatheIn\"];\n\n\t\t        if (hero.isHolding) {\n\t\t            hero.curItem.pos.y = hero.pos.y + 18;\n\t\t        }\n\t\t    }\n\t\t    else if (foo > 150 && foo <= 200) {\n\t\t        pos = spriteArr[\"playerDown_breatheOut\"];\n\n\t\t        if (hero.isHolding) {\n\t\t            hero.curItem.pos.y = hero.pos.y + 22;\n\t\t        }\n\t\t    }\n\t\t}\n\n        // invincible\n\t\tvar inv = invincibleTimer % 40;\n\t\t\n\t\tif(hero.invincible && (inv >= 0 && inv <= 16)){\n\t\t\tpos = {x: -1, y: -1};\n\t\t}\n\n\t\t\n\t\thero.sx = pos.x;\n\t\thero.sy = pos.y;\n\t}\n\t\n\t/*********************** Render ***********************/\n\tfunction drawHero(){\n\t    if (imgReady && hero.sx >= 0 && hero.sy >= 0) {\n\t\t    ctx.drawImage(img, hero.sx, hero.sy, hero.w, hero.h, Math.round(hero.pos.x), Math.round(hero.pos.y), hero.w, hero.h);\n    \t}\n\t}\n\t\t\n    // used to draw things over the hero\n\tfunction drawAfterHero() {\n\t    if (hero.isHolding) {\n\t        hero.curItem.draw();\n\t    }\n\t}\n\t\t\n\treturn {\n\t\tsx: 0,\t\t\t\t// sprite position\n\t\tsy: 0,\n\t\tlvlX: 0,\t\t\t\n\t\tw: 48,\n\t\th: 65,\n\t\tvX: 0,              // maxVx/maxVy are in heroInput.js\n\t\tvY: 0,\n\t\taX: 0.17,\n\t\taY: 0.82,\n\t\tjumpMod: 4,\n\t\tjumpMod0: 4,\n        idleTime: 0,\n\t\tdir: Dir.RIGHT,\n\t\tonLadder: false,\n\t\tinvincible: false,\n\t\tisJumping: false,\n\t\tisHolding: false,\n\t\tisOnObj: true,\n\t\tcurItem: null,      // the item in hand\n        lives: 3,\n\t\thealth: 3,\n\t\tmaxHealth: 3,\n\t\tmedKits: 1,\n\t\thealthLvl: 1,\n\t\tmana: 0,\n\t\tmaxMana: 4,\n\t\tmanaKits: 1,\n\t\tmanaLvl: 1,\n\t\tammo: 20,\n\t\tcash: 0,\n\t\tlvl: 1,\n\t\txp: 0,\n\t\txpNeeded: 50,\n\t\tbulletArr: [],\n\t\t\n\n\t\tinit: function(){\n\t\t\timg = new Image();\n\t\t\timg.onload = function () { imgReady = true; };\n\t\t\timg.src = \"img/sprites/player/player.png\";\n\t\t\t\n\t\t\t// grab texturePacker's sprite coords\n\t\t\t$.get(\"img/sprites/player/player.xml\", function(xml){\n\t\t\t\tvar wrap = $(xml).find(\"sprite\");\n\t\t\t\t\n\t\t\t\t$(wrap).each(function(){\n\t\t\t\t\tvar name = $(this).attr('n'),\n\t\t\t\t\t\tx = $(this).attr('x'),\n\t\t\t\t\t\ty = $(this).attr('y');\n\t\t\t\t\t\n\t\t\t\t\tname = name.substring(0, name.length-4);\n\t\t\t\t\tspriteArr[name] = {x: x, y: y};\n\t\t\t\t});\n\t\t\t\t\n\t\t\t});\n\t\t\t\n\t\t\tinput = HeroInputComponent();\n\t\t\tphysics = HeroPhysicsComponent();\n\t\t\tgraphics = HeroGraphicsComponent();\n\n            // setup hero bounding box for collision detection\n\t\t\t$.extend(hero, new SAT.Box(new SAT.Vector(0, 0), hero.w, hero.h).toPolygon());\n\t\t},\n\t\t\n\t\tupdate: function () {\n\t\t    input.check();                      // updates velocities\n\t\t\tphysics.updatePosition();          // updates positions\n\t\t\tphysics.checkCollision();          // fix positions\n\n\t\t\tcheckHealth();\n\t\t\tgetSpritePos();\n\t\t},\n\t\n\t\trender: function () {\n\t\t    drawHero();\n\t\t    graphics.drawBullets();\n\t\t    drawAfterHero();\n\t\t},\n\n\t\tlanded: function(y) {\n\t\t    hero.isOnObj = true;\n\t\t    hero.isJumping = false;\n\t\t    hero.vY = 0;\n\t\t    hero.pos.y -= y;\n\t\t}\n\t};\n})();\n",
    "/// <reference path=\"../linker.js\" />\n\n/*\n    The graphics component of hero.\n*/\nvar HeroGraphicsComponent = function () {\n\n    var shurikenReady = false,\n        shuriken = new Image()\n    ;\n\n    shuriken.src = \"img/shuriken.png\";\n    shuriken.onload = function () {\n        shurikenReady = true;\n    };\n\n    return {\n        drawBullets: function(){\n\t\t    for(var i=0; i < hero.bulletArr.length; ++i){\n\t\t        var dirOffset = hero.bulletArr[i].dirR ?\n    \t\t\t\t\t\t\t    hero.w : \n    \t\t\t\t\t\t\t    0;\n\t            \n\t\t        hero.bulletArr[i].deg += 5;\n            \n\t\t        if (shurikenReady) {\n\t\t            Graphics.drawRotate(\n                        shuriken,\n                        hero.bulletArr[i].pos.x + dirOffset,\n                        hero.bulletArr[i].pos.y + 20,\n                        hero.bulletArr[i].deg\n                    );\n\t\t        }\n\t\t    }\n        }\n    };\n};\n",
    "/// <reference path=\"../linker.js\" />\n\n// The physics component of hero.\nvar HeroPhysicsComponent = function () {\n\n    /*\n        Updates projectiles position.\n\n        Tests for projectile collision against screen.\n        Tests for projectile collision against objects.\n    */\n    function projectileHandler() {\n        for (var i = 0; i < hero.bulletArr.length; ++i) {\n            hero.bulletArr[i].pos.x += hero.bulletArr[i].dirR ? Shuriken.speed : -Shuriken.speed;   // update position\n\n            if (hero.bulletArr[i].pos.x > FULLW || hero.bulletArr[i].pos.x < 0) {\t\t    // projectile and screen\n                hero.bulletArr.splice(i, 1); // remove ith item\n            }\n            else {\n                Physics.testObjObjs(hero.bulletArr[i], function(){                  // projectile and objects\n                    hero.bulletArr.splice(i, 1);\n                });\n            }\n        }\n    }\n\n    function screenCollision() {\n        if (hero.pos.y < -hero.h*2) {                 // feet 2x above top of screen\n            hero.pos.y = -hero.h*2;\n            hero.vY = 0;\n        }\n        else if (hero.pos.y >= FULLH + hero.h*2) {  // 2x below bottom of screen\n            if (!game.over) {\n                utils.deathSequence();\n            }\n        }\n\n        if (hero.pos.x < 0) { \t\t\t\t\t\t// left\n            hero.pos.x = 0;\n            hero.vX = 0;\n        }\n        else if (hero.pos.x > (FULLW - hero.w)) { \t// right \n            hero.pos.x = FULLW - hero.w;\n            hero.vX = 0;\n        }\n    }\n\n    function levelCollision() {\n        hero.isOnObj = false;   // prevents jumping after walking off platform\n\n        Physics.testObjObjs(hero, function(r) {\n            // alias the collision direction\n            var dir = {\n                x: Dir.NONE,\n                y: Dir.NONE\n            };\n\n            if(r.overlapN.y === 1)\n                dir.y = Dir.TOP;\n            else if(r.overlapN.y === -1)\n                dir.y = Dir.BOT;\n\n            if(r.overlapN.x === 1)\n                dir.x = Dir.LEFT;\n            else if(r.overlapN.y === -1)\n                dir.x = Dir.RIGHT;\n\n\n            // check object type\n            if(r.b.type === JQObject.SLOPE || r.b.type === JQObject.POLY || r.b.type === JQObject.HILL) {\n                //r.a.pos.x -= r.overlapV.x;\n\n                if(hero.vY >= 0) { // prevents hooking on edge\n                    hero.landed(r.overlapV.y);\n                }\n            }\n            else if(r.b.type === JQObject.ELEVATOR) {\n                if(dir.y === Dir.TOP && hero.vY >= 0) {\n                    hero.isOnObj = true;\n                    hero.isJumping = false;\n                    hero.vY = (r.b.vY > 0) ? r.b.vY : 0;\n\n                    r.a.pos.y -= r.overlapV.y;\n                }\n            }\n            else {\n                r.a.pos.x -= r.overlapV.x;\n\n                if(dir.y === Dir.TOP && hero.vY >= 0) {  // prevents hooking on edge\n                    hero.landed(r.overlapV.y);\n                }\n                else if(dir.y === Dir.BOT && hero.vY <= 0) {  // prevents hooking on edge\n                    hero.vY = 0;\n                    r.a.pos.y -= r.overlapV.y;\n                }\n            }\n        });\n        \n        if (hero.isHolding) {\n            if (hero.vX === 0) {\n                hero.curItem.pos.x = hero.pos.x + 7;\n                hero.curItem.pos.y = hero.pos.y + 20;\n            }\n            else {\n                hero.curItem.pos.x = hero.pos.x + ((hero.dir === Dir.RIGHT) ? 45 : -32);\n                hero.curItem.pos.y = hero.pos.y + 16;\n            }\n        }\n\n        Physics.testHeroItems(function (r, idx) {\n            if (r.b.type === JQObject.CRATE) {      // TODO: make more generic\n                if (r.overlapN.y === 1) {           // on top\n                    hero.pos.y -= r.overlapV.y;\n                    hero.isOnObj = true;\n                    hero.isJumping = false;\n\n                    hero.vY = 0;\n\n                    if(typeof (r.b.onObj) !== \"undefined\" && r.b.onObj !== null) {  // hero on crate on elevator\n                        if(r.b.onObj.type === JQObject.ELEVATOR) {\n                            hero.vY = r.b.vY;\n                        }\n                    }\n                }\n                else if (!hero.isHolding && r.b.grabbable && !r.b.recentlyHeld) {\n                    if (r.b.isOnObj === true) {\n                        r.b.isOnObj = false;\n\n                        if (r.b.onObj !== null) {\n                            r.b.onObj.grabbable = true;\n                            r.b.onObj = null;\n                        }\n                    }\n\n                    r.b.isBeingHeld = true;\n\n                    hero.curItem = r.b;\n                    hero.isHolding = true;\n\n                    level.items.splice(idx, 1);\n                }\n            }\n            else {\n                audio.itemPickedUp.play();\n\n                if (r.b.type === JQObject.SACK) {\n                    hero.ammo += r.b.val;\n                }\n                else if (r.b.type === JQObject.CASH) {\n                    hero.cash += r.b.val;\n                }\n\n                level.items.splice(idx, 1);\n            }\n        });\n    }\n\n    return {\n        updatePosition: function (){\t\n            // TODO: buggy at edges, quickly changing direction incorrectly causes an updateView()\n            \n            if(((hero.dir === Dir.RIGHT && hero.pos.x >= (HALFW + 35)) ||\n               (hero.dir === Dir.LEFT && hero.pos.x <= (HALFW - 45))) &&\n               (hero.lvlX + hero.vX >= 0) &&\n               (hero.lvlX + hero.vX <= level.curLvl.width - FULLW)\n            ){\n                hero.lvlX += hero.vX;\n\n                // updateProjectileView\n                for(var i = 0; i < hero.bulletArr.length; ++i) {\n                    hero.bulletArr[i].pos.x -= hero.vX;\n                }\n\n                level.updateView();\n            }\n            else {\n                hero.pos.x += hero.vX;\n            }\n\n            if (!hero.onLadder) {\n                hero.pos.y += hero.vY;\n            }\n        },\n\n        checkCollision: function () {\n            projectileHandler();\n            screenCollision();\t    // hero and screen\n            levelCollision();\n        }\n    };\n};\n",
    "/// <reference path=\"../linker.js\" />\n\nvar KeyCode = Object.freeze({\n\tENTER: 13,\n\tCTRL: 17,\n\tA: 65,\n\tD: 68,\n\tF: 70,\n\tH: 72,\n\tJ: 74,\n\tK: 75,\n\tM: 77,\n\tO: 79,\n\tR: 82,\n\tS: 83,\n\tW: 87,\n\tEMPTY: -1,\n\tSPACEBAR: 32\n});\n\n// The input component of hero.\nvar HeroInputComponent = function() {\n\tvar maxVx = 3,\n\t\tmaxVy = 10\n\t;\n\n\t// global key vars\n\tkeysDown = {};\n\tlastKeyDown = -1;\n\n\t$(document).on('click', '.resize', function () {\n\t\tif ($(this).hasClass('off')) {\n\t\t\t$(this).removeClass('off').addClass('on');\n\t\t\t$(this).children('iron-icon').prop('icon', 'icons:fullscreen-exit');\n\t\t}\n\t\telse if($(this).hasClass('on')) {\n\t\t\t$(this).removeClass('on').addClass('off');\n\t\t\t$(this).children('iron-icon').prop('icon', 'icons:fullscreen');\n\t\t}\n\n\t\tutils.toggleFullScreen();\n\t});\n\n\taddEventListener('keydown', function(e) {\n\t\tif (e.keyCode === KeyCode.SPACEBAR) {\n\t\t\te.preventDefault(); \t\t\t    // scrolling to bottom of page\n\t\t}\n\t\telse if(e.keyCode === KeyCode.M) {\t    // mute/unmute\n\t\t\taudio.handleMuteButton();\n\t\t}\n\t\telse if(e.keyCode === KeyCode.F) {     // resize\n\t\t\t$('.resize').trigger('click');\n\t\t}\n\t\telse if(e.keyCode === KeyCode.K &&\t\t// jump; TODO: move to check() function\n\t\t\t   (!hero.isJumping && ((lastKeyDown !== KeyCode.K) || !(keysDown[KeyCode.K]))) &&\n\t\t\t   hero.isOnObj\n\t\t) {\n\t\t\taudio.jump.play();\n\t\t\thero.vY = 0;\n\t\t\thero.isJumping = true;\n\t\t\thero.isOnObj = false;\n\t\t}\n\t\telse if (e.keyCode === KeyCode.J &&\t\t// shoot; TODO: move to check() function\n\t\t\t\t((lastKeyDown != KeyCode.J) || !(keysDown[KeyCode.J]))\n\t\t) {\n\t\t\tif(hero.ammo > 0 && !hero.isHolding) {\n\t\t\t\taudio.play(audio.effort);\n\n\t\t\t\tvar projectile = new GameObj(JQObject.SHURIKEN, hero.pos.x, hero.pos.y + Shuriken.h/2, Shuriken.w, Shuriken.h);\n\t\t\t\tprojectile.dirR = (hero.dir === Dir.RIGHT);\n\t\t\t\tprojectile.deg = 0;\n\n\t\t\t\thero.bulletArr.push(projectile);\n\n\t\t\t\t--hero.ammo;\n\t\t\t\thero.idleTime = 0;\n\t\t\t}\n\t\t}\n\t\telse if(e.keyCode == KeyCode.O) {      // options\n\t\t\tutils.toggleMenu();\n\t\t}\n\n\t\tlastKeyDown = e.keyCode;\n\t\tkeysDown[e.keyCode] = true;\n\t}, false);\n\n\taddEventListener('keyup', function(e) {\n\t\tdelete keysDown[e.keyCode];\n\t}, false);\n\n\n\treturn {\n\t\tcheck: function() {\n\t\t\tvar doGravity = false;\n\n\t\t\t// jumping\n\t\t\tif(hero.isJumping) {\n\t\t\t\tif(hero.jumpMod > 0) {\n\t\t\t\t\thero.vY -= hero.aY * hero.jumpMod--;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdoGravity = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\thero.jumpMod = hero.jumpMod0;\n\t\t\t\tdoGravity = true;\n\t\t\t}\n\n\t\t\tif (doGravity && !hero.onLadder) {\n\t\t\t\tvar fixVy = hero.vY + game.gravity*2;\n\n\t\t\t\tif (fixVy > maxVy) {\n\t\t\t\t\thero.vY = maxVy;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\thero.vY = fixVy;\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t\t// --------- keys pressed --------\n\t\t\tvar leftOrRight = false;\n\t\t\t// left\n\t\t\tif(keysDown[KeyCode.A]){\n\t\t\t\thero.vX = (Math.abs(hero.vX - hero.aX) > maxVx) ? -maxVx : (hero.vX - hero.aX);\n\t\t\t\thero.dir = Dir.LEFT;\n\t\t\t\tleftOrRight = true;\n\t\t\t}\n\n\t\t\t// right\n\t\t\tif(keysDown[KeyCode.D]) {\n\t\t\t\thero.vX = (Math.abs(hero.vX + hero.aX) > maxVx) ? maxVx : (hero.vX + hero.aX);\n\t\t\t\thero.dir = Dir.RIGHT;\n\t\t\t\tleftOrRight = true;\n\t\t\t}\n\t\t\n\t\t\tif(Math.abs(hero.vX) < hero.aX){    \n\t\t\t\thero.vX = 0;\n\t\t\t}\n\t\t\telse if(!leftOrRight){\n\t\t\t\t//hero.vX += (hero.vX > 0) ? -game.friction : game.friction;\n\t\t\t\thero.vX /= 1.26;\n\t\t\t}\n\t\t\n\n\t\t\t// up\n\t\t\tif(keysDown[KeyCode.W]) {\n\t\t\t\tif (hero.onLadder) {\n\t\t\t\t\t--hero.pos.y;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// down\n\t\t\tif(keysDown[KeyCode.S]) {\n\t\t\t\tif (hero.onLadder) {\n\t\t\t\t\t++hero.pos.y;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\n\t\t\t// drop \n\t\t\tif(keysDown[KeyCode.SPACEBAR]) {\n\t\t\t\tif(hero.isHolding) {\n\t\t\t\t\thero.isHolding = false;\n\t\t\t\t\thero.curItem.isBeingHeld = false;\n\t\t\t\t\thero.curItem.recentlyHeld = true;       // TODO: fix api\n\t\t\t\t\tlevel.items.push(hero.curItem);\n\t\t\t\t\thero.curItem = null;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\n\t\t\t//----- heal (h)\n\t\t\tif(keysDown[KeyCode.H]){\n\t\t\t\tif(hero.medKits > 0 && hero.health < hero.maxHealth){\n\t\t\t\t\t++hero.health;\n\t\t\t\t\t--hero.medKits;\n\n\t\t\t\t\taudio.play(audio.enchant, true);\n\t\t\t\t}\n\t\t\t}\n\t\t\n\t\t\n\t\t\t// restore\n\t\t\tif(keysDown[KeyCode.R] && !(keysDown[KeyCode.CTRL])){\n\t\t\t\tif(hero.manaKits > 0 && hero.mana < hero.maxMana){\n\t\t\t\t\t++hero.mana;\n\t\t\t\t\t--hero.manaKits;\n\n\t\t\t\t\taudio.play(audio.enchant, true);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n};",
    "var Main = (function() {\n    function setCanvasGlobals() {\n        canvas = $(\"canvas\")[0];\n        ctx = canvas.getContext(\"2d\");\n        \n        FULLW = canvas.width;\n        FULLH = canvas.height - game.padHUD;\n        HALFW = FULLW / 2;\n        HALFH = FULLH / 2;\n    }\n\n    function loadingScreen() {\n        ctx.fillStyle = \"#e1e1e1\";\n        ctx.font = \"25px 'Press Start 2P'\";\n        ctx.fillText(\"LOADING...\", HALFW - 80, HALFH + 20);\n    }\n\n    function debug() {\n        // dev enviroment\n        if(location.hostname === \"jonsquest\") {\n            window.DEBUG = true;\n            window.DEBUG_OPT = {\n                'lvl': 3\n            };\n\n            // speed up canvas transition\n            $(canvas).css({\"transition\": \"opacity 0.01s\"});\n\n            // skip start screen\n            lastKeyDown = KeyCode.ENTER;\n\n            // mute audio\n            //audio.handleMuteButton();\n        }\n    }\n\n\n    return {\n        init: function() {\n            setCanvasGlobals();\n            loadingScreen();\n\n            hero.init();\n            audio.init();\n            level.init();\n            HUD.init();\n\n            // wait for google font\n            $(document).on('fontLoaded', function() {\n                // game timer\n                setInterval(function() {\n                    ++game.actualTime;\n                }, 1000);\n\n                // start the game\n                game.start();\n\n                //debug();\n            });\n        }\n    }\n})();\n\n$(function () {\n    // load font\n    window.WebFontConfig = {\n        google: {\n            families: ['Press Start 2P']\n        },\n        \n        active: function() {\n            $(document).trigger('fontLoaded');\n        },\n        \n        inactive: function() {\n            alert(\"There was a problem loading a font from google, some text may not render correctly (refreshing the page may fix the issue).\");\n            $(document).trigger(\"fontLoaded\");\n        }\n    };\n\n    (function() {\n        var wf = document.createElement(\"script\");\n        wf.src = \"//ajax.googleapis.com/ajax/libs/webfont/1/webfont.js\";\n        wf.type = \"text/javascript\";\n        wf.async = \"true\";\n        var s = document.getElementsByTagName(\"script\")[0];\n        s.parentNode.insertBefore(wf, s);\n    })();\n\n    Main.init();\n});"
  ]
}