{
  "version": 3,
  "file": "jonsQuest.js",
  "sources": [
    "js/physics/SAT.js",
    "js/utils.js",
    "js/audio/audio.js",
    "js/graphics/graphics.js",
    "js/physics/physics.js",
    "js/engine/gameObject.js",
    "js/engine/gameItem.js",
    "js/engine/hud.js",
    "js/enemy/enemy.js",
    "js/level/level.js",
    "js/level/lvlComplete.js",
    "js/level/startScreen.js",
    "js/level/level1.js",
    "js/level/level2.js",
    "js/level/level3.js",
    "js/engine/game.js",
    "js/hero/hero.js",
    "js/hero/heroGraphics.js",
    "js/hero/heroPhysics.js",
    "js/hero/heroInput.js",
    "js/main.js"
  ],
  "names": [],
  "mappings": "AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,I;ACrzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3SA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACphBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,E;ACjIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3VA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,K;AC9NA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA",
  "sourcesContent": [
    "// Version 0.2 - Copyright 2013 -  Jim Riecken <jimr@jimr.ca>\r\n//\r\n// Released under the MIT License - https://github.com/jriecken/sat-js\r\n//\r\n// A simple library for determining intersections of circles and\r\n// polygons using the Separating Axis Theorem.\r\n/** @preserve SAT.js - Version 0.2 - Copyright 2013 - Jim Riecken <jimr@jimr.ca> - released under the MIT License. https://github.com/jriecken/sat-js */\r\n\r\n/*global define: false, module: false*/\r\n/*jshint shadow:true, sub:true, forin:true, noarg:true, noempty:true, \r\n  eqeqeq:true, bitwise:true, strict:true, undef:true, \r\n  curly:true, browser:true */\r\n\r\n// Create a UMD wrapper for SAT. Works in:\r\n//\r\n//  - Plain browser via global SAT variable\r\n//  - AMD loader (like require.js)\r\n//  - Node.js\r\n//\r\n// The quoted properties all over the place are used so that the Closure Compiler\r\n// does not mangle the exposed API in advanced mode.\r\n/**\r\n * @param {*} root - The global scope\r\n * @param {Function} factory - Factory that creates SAT module\r\n */\r\n(function (root, factory) {\r\n  \"use strict\";\r\n  if (typeof define === 'function' && define['amd']) {\r\n    define(factory);\r\n  } else if (typeof exports === 'object') {\r\n    module['exports'] = factory();\r\n  } else {\r\n    root['SAT'] = factory();\r\n  }\r\n}(this, function () {\r\n  \"use strict\";\r\n\r\n  var SAT = {};\r\n\r\n  //\r\n  // ## Vector\r\n  //\r\n  // Represents a vector in two dimensions with `x` and `y` properties.\r\n\r\n\r\n  // Create a new Vector, optionally passing in the `x` and `y` coordinates. If\r\n  // a coordinate is not specified, it will be set to `0`\r\n  /** \r\n   * @param {?number=} x The x position.\r\n   * @param {?number=} y The y position.\r\n   * @constructor\r\n   */\r\n  function Vector(x, y) {\r\n    this['x'] = x || 0;\r\n    this['y'] = y || 0;\r\n  }\r\n  SAT['Vector'] = Vector;\r\n  // Alias `Vector` as `V`\r\n  SAT['V'] = Vector;\r\n\r\n\r\n  // Copy the values of another Vector into this one.\r\n  /**\r\n   * @param {Vector} other The other Vector.\r\n   * @return {Vector} This for chaining.\r\n   */\r\n  Vector.prototype['copy'] = Vector.prototype.copy = function(other) {\r\n    this['x'] = other['x'];\r\n    this['y'] = other['y'];\r\n    return this;\r\n  };\r\n\r\n  // Change this vector to be perpendicular to what it was before. (Effectively\r\n  // roatates it 90 degrees in a clockwise direction)\r\n  /**\r\n   * @return {Vector} This for chaining.\r\n   */\r\n  Vector.prototype['perp'] = Vector.prototype.perp = function() {\r\n    var x = this['x'];\r\n    this['x'] = this['y'];\r\n    this['y'] = -x;\r\n    return this;\r\n  };\r\n\r\n  // Rotate this vector (counter-clockwise) by the specified angle (in radians).\r\n  /**\r\n   * @param {number} angle The angle to rotate (in radians)\r\n   * @return {Vector} This for chaining.\r\n   */\r\n  Vector.prototype['rotate'] = Vector.prototype.rotate = function (angle) {\r\n    var x = this['x'];\r\n    var y = this['y'];\r\n    this['x'] = x * Math.cos(angle) - y * Math.sin(angle);\r\n    this['y'] = x * Math.sin(angle) + y * Math.cos(angle);\r\n    return this;\r\n  };\r\n\r\n  // Reverse this vector.\r\n  /**\r\n   * @return {Vector} This for chaining.\r\n   */\r\n  Vector.prototype['reverse'] = Vector.prototype.reverse = function() {\r\n    this['x'] = -this['x'];\r\n    this['y'] = -this['y'];\r\n    return this;\r\n  };\r\n  \r\n\r\n  // Normalize this vector.  (make it have length of `1`)\r\n  /**\r\n   * @return {Vector} This for chaining.\r\n   */\r\n  Vector.prototype['normalize'] = Vector.prototype.normalize = function() {\r\n    var d = this.len();\r\n    if(d > 0) {\r\n      this['x'] = this['x'] / d;\r\n      this['y'] = this['y'] / d;\r\n    }\r\n    return this;\r\n  };\r\n  \r\n  // Add another vector to this one.\r\n  /**\r\n   * @param {Vector} other The other Vector.\r\n   * @return {Vector} This for chaining.\r\n   */\r\n  Vector.prototype['add'] = Vector.prototype.add = function(other) {\r\n    this['x'] += other['x'];\r\n    this['y'] += other['y'];\r\n    return this;\r\n  };\r\n  \r\n  // Subtract another vector from this one.\r\n  /**\r\n   * @param {Vector} other The other Vector.\r\n   * @return {Vector} This for chaiing.\r\n   */\r\n  Vector.prototype['sub'] = Vector.prototype.sub = function(other) {\r\n    this['x'] -= other['x'];\r\n    this['y'] -= other['y'];\r\n    return this;\r\n  };\r\n  \r\n  // Scale this vector. An independant scaling factor can be provided\r\n  // for each axis, or a single scaling factor that will scale both `x` and `y`.\r\n  /**\r\n   * @param {number} x The scaling factor in the x direction.\r\n   * @param {?number=} y The scaling factor in the y direction.  If this\r\n   *   is not specified, the x scaling factor will be used.\r\n   * @return {Vector} This for chaining.\r\n   */\r\n  Vector.prototype['scale'] = Vector.prototype.scale = function(x,y) {\r\n    this['x'] *= x;\r\n    this['y'] *= y || x;\r\n    return this; \r\n  };\r\n  \r\n  // Project this vector on to another vector.\r\n  /**\r\n   * @param {Vector} other The vector to project onto.\r\n   * @return {Vector} This for chaining.\r\n   */\r\n  Vector.prototype['project'] = Vector.prototype.project = function(other) {\r\n    var amt = this.dot(other) / other.len2();\r\n    this['x'] = amt * other['x'];\r\n    this['y'] = amt * other['y'];\r\n    return this;\r\n  };\r\n  \r\n  // Project this vector onto a vector of unit length. This is slightly more efficient\r\n  // than `project` when dealing with unit vectors.\r\n  /**\r\n   * @param {Vector} other The unit vector to project onto.\r\n   * @return {Vector} This for chaining.\r\n   */\r\n  Vector.prototype['projectN'] = Vector.prototype.projectN = function(other) {\r\n    var amt = this.dot(other);\r\n    this['x'] = amt * other['x'];\r\n    this['y'] = amt * other['y'];\r\n    return this;\r\n  };\r\n  \r\n  // Reflect this vector on an arbitrary axis.\r\n  /**\r\n   * @param {Vector} axis The vector representing the axis.\r\n   * @return {Vector} This for chaining.\r\n   */\r\n  Vector.prototype['reflect'] = Vector.prototype.reflect = function(axis) {\r\n    var x = this['x'];\r\n    var y = this['y'];\r\n    this.project(axis).scale(2);\r\n    this['x'] -= x;\r\n    this['y'] -= y;\r\n    return this;\r\n  };\r\n  \r\n  // Reflect this vector on an arbitrary axis (represented by a unit vector). This is\r\n  // slightly more efficient than `reflect` when dealing with an axis that is a unit vector.\r\n  /**\r\n   * @param {Vector} axis The unit vector representing the axis.\r\n   * @return {Vector} This for chaining.\r\n   */\r\n  Vector.prototype['reflectN'] = Vector.prototype.reflectN = function(axis) {\r\n    var x = this['x'];\r\n    var y = this['y'];\r\n    this.projectN(axis).scale(2);\r\n    this['x'] -= x;\r\n    this['y'] -= y;\r\n    return this;\r\n  };\r\n  \r\n  // Get the dot product of this vector and another.\r\n  /**\r\n   * @param {Vector}  other The vector to dot this one against.\r\n   * @return {number} The dot product.\r\n   */\r\n  Vector.prototype['dot'] = Vector.prototype.dot = function(other) {\r\n    return this['x'] * other['x'] + this['y'] * other['y'];\r\n  };\r\n  \r\n  // Get the squared length of this vector.\r\n  /**\r\n   * @return {number} The length^2 of this vector.\r\n   */\r\n  Vector.prototype['len2'] = Vector.prototype.len2 = function() {\r\n    return this.dot(this);\r\n  };\r\n  \r\n  // Get the length of this vector.\r\n  /**\r\n   * @return {number} The length of this vector.\r\n   */\r\n  Vector.prototype['len'] = Vector.prototype.len = function() {\r\n    return Math.sqrt(this.len2());\r\n  };\r\n  \r\n  // ## Circle\r\n  //\r\n  // Represents a circle with a position and a radius.\r\n\r\n  // Create a new circle, optionally passing in a position and/or radius. If no position\r\n  // is given, the circle will be at `(0,0)`. If no radius is provided, the circle will\r\n  // have a radius of `0`.\r\n  /**\r\n   * @param {Vector=} pos A vector representing the position of the center of the circle\r\n   * @param {?number=} r The radius of the circle\r\n   * @constructor\r\n   */\r\n  function Circle(pos, r) {\r\n    this['pos'] = pos || new Vector();\r\n    this['r'] = r || 0;\r\n  }\r\n  SAT['Circle'] = Circle;\r\n\r\n  // ## Polygon\r\n  //\r\n  // Represents a *convex* polygon with any number of points (specified in counter-clockwise order)\r\n  //\r\n  // The edges/normals of the polygon will be calculated on creation and stored in the\r\n  // `edges` and `normals` properties. If you change the polygon's points, you will need\r\n  // to call `recalc` to recalculate the edges/normals.\r\n\r\n  // Create a new polygon, passing in a position vector, and an array of points (represented\r\n  // by vectors relative to the position vector). If no position is passed in, the position\r\n  // of the polygon will be `(0,0)`.\r\n  /**\r\n   * @param {Vector=} pos A vector representing the origin of the polygon. (all other\r\n   *   points are relative to this one)\r\n   * @param {Array.<Vector>=} points An array of vectors representing the points in the polygon,\r\n   *   in counter-clockwise order.\r\n   * @constructor\r\n   */\r\n  function Polygon(pos, points) {\r\n    this['pos'] = pos || new Vector();\r\n    this['points'] = points || [];\r\n    this.recalc();\r\n  }\r\n  SAT['Polygon'] = Polygon;\r\n  \r\n  // Recalculates the edges and normals of the polygon. This **must** be called\r\n  // if the `points` array is modified at all and the edges or normals are to be\r\n  // accessed.\r\n  /**\r\n   * @return {Polygon} This for chaining.\r\n   */\r\n  Polygon.prototype['recalc'] = Polygon.prototype.recalc = function() {\r\n    // The edges here are the direction of the `n`th edge of the polygon, relative to\r\n    // the `n`th point. If you want to draw a given edge from the edge value, you must\r\n    // first translate to the position of the starting point.\r\n    this['edges'] = [];\r\n    // The normals here are the direction of the normal for the `n`th edge of the polygon, relative\r\n    // to the position of the `n`th point. If you want to draw an edge normal, you must first\r\n    // translate to the position of the starting point.\r\n    this['normals'] = [];\r\n    var points = this['points'];\r\n    var len = points.length;\r\n    for (var i = 0; i < len; i++) {\r\n      var p1 = points[i]; \r\n      var p2 = i < len - 1 ? points[i + 1] : points[0];\r\n      var e = new Vector().copy(p2).sub(p1);\r\n      var n = new Vector().copy(e).perp().normalize();\r\n      this['edges'].push(e);\r\n      this['normals'].push(n);\r\n    }\r\n    return this;\r\n  };\r\n\r\n  // Rotates this polygon counter-clockwise around the origin of *its local coordinate system* (i.e. `pos`).\r\n  //\r\n  // Note: You do **not** need to call `recalc` after rotation.\r\n  /**\r\n   * @param {number} angle The angle to rotate (in radians)\r\n   * @return {Polygon} This for chaining.\r\n   */\r\n  Polygon.prototype['rotate'] = Polygon.prototype.rotate = function(angle) {\r\n    var i;\r\n    var points = this['points'];\r\n    var edges = this['edges'];\r\n    var normals = this['normals'];\r\n    var len = points.length;\r\n    for (i = 0; i < len; i++) {\r\n      points[i].rotate(angle);\r\n      edges[i].rotate(angle);\r\n      normals[i].rotate(angle);\r\n    }\r\n    return this;\r\n  };\r\n\r\n  // Translates the points of this polygon by a specified amount relative to the origin of *its own coordinate\r\n  // system* (i.e. `pos`).\r\n  //\r\n  // This is most useful to change the \"center point\" of a polygon.\r\n  //\r\n  // Note: You do **not** need to call `recalc` after translation.\r\n  /**\r\n   * @param {number} x The horizontal amount to translate.\r\n   * @param {number} y The vertical amount to translate.\r\n   * @return {Polygon} This for chaining.\r\n   */\r\n  Polygon.prototype['translate'] = Polygon.prototype.translate = function (x, y) {\r\n    var i;\r\n    var points = this['points'];\r\n    var len = points.length;\r\n    for (i = 0; i < len; i++) {\r\n      points[i].x += x;\r\n      points[i].y += y;\r\n    }\r\n    return this;\r\n  };\r\n\r\n  // ## Box\r\n  //\r\n  // Represents an axis-aligned box, with a width and height.\r\n\r\n\r\n  // Create a new box, with the specified position, width, and height. If no position\r\n  // is given, the position will be `(0,0)`. If no width or height are given, they will\r\n  // be set to `0`.\r\n  /**\r\n   * @param {Vector=} pos A vector representing the top-left of the box.\r\n   * @param {?number=} w The width of the box.\r\n   * @param {?number=} h The height of the box.\r\n   * @constructor\r\n   */\r\n  function Box(pos, w, h) {\r\n    this['pos'] = pos || new Vector();\r\n    this['w'] = w || 0;\r\n    this['h'] = h || 0;\r\n  }\r\n  SAT['Box'] = Box;\r\n\r\n  // Returns a polygon whose edges are the same as this box.\r\n  /**\r\n   * @return {Polygon} A new Polygon that represents this box.\r\n   */\r\n  Box.prototype['toPolygon'] = Box.prototype.toPolygon = function() {\r\n    var pos = this['pos'];\r\n    var w = this['w'];\r\n    var h = this['h'];\r\n    return new Polygon(new Vector(pos['x'], pos['y']), [\r\n     new Vector(), new Vector(w, 0), \r\n     new Vector(w,h), new Vector(0,h)\r\n    ]);\r\n  };\r\n  \r\n  // ## Response\r\n  //\r\n  // An object representing the result of an intersection. Contains:\r\n  //  - The two objects participating in the intersection\r\n  //  - The vector representing the minimum change necessary to extract the first object\r\n  //    from the second one (as well as a unit vector in that direction and the magnitude\r\n  //    of the overlap)\r\n  //  - Whether the first object is entirely inside the second, and vice versa.\r\n  /**\r\n   * @constructor\r\n   */  \r\n  function Response() {\r\n    this['a'] = null;\r\n    this['b'] = null;\r\n    this['overlapN'] = new Vector();\r\n    this['overlapV'] = new Vector();\r\n    this.clear();\r\n  }\r\n  SAT['Response'] = Response;\r\n\r\n  // Set some values of the response back to their defaults.  Call this between tests if\r\n  // you are going to reuse a single Response object for multiple intersection tests (recommented\r\n  // as it will avoid allcating extra memory)\r\n  /**\r\n   * @return {Response} This for chaining\r\n   */\r\n  Response.prototype['clear'] = Response.prototype.clear = function() {\r\n    this['aInB'] = true;\r\n    this['bInA'] = true;\r\n    this['overlap'] = Number.MAX_VALUE;\r\n    return this;\r\n  };\r\n\r\n  // ## Object Pools\r\n\r\n  // A pool of `Vector` objects that are used in calculations to avoid\r\n  // allocating memory.\r\n  /**\r\n   * @type {Array.<Vector>}\r\n   */\r\n  var T_VECTORS = [];\r\n  for (var i = 0; i < 10; i++) { T_VECTORS.push(new Vector()); }\r\n  \r\n  // A pool of arrays of numbers used in calculations to avoid allocating\r\n  // memory.\r\n  /**\r\n   * @type {Array.<Array.<number>>}\r\n   */\r\n  var T_ARRAYS = [];\r\n  for (var i = 0; i < 5; i++) { T_ARRAYS.push([]); }\r\n\r\n  // ## Helper Functions\r\n\r\n  // Flattens the specified array of points onto a unit vector axis,\r\n  // resulting in a one dimensional range of the minimum and\r\n  // maximum value on that axis.\r\n  /**\r\n   * @param {Array.<Vector>} points The points to flatten.\r\n   * @param {Vector} normal The unit vector axis to flatten on.\r\n   * @param {Array.<number>} result An array.  After calling this function,\r\n   *   result[0] will be the minimum value,\r\n   *   result[1] will be the maximum value.\r\n   */\r\n  function flattenPointsOn(points, normal, result) {\r\n    var min = Number.MAX_VALUE;\r\n    var max = -Number.MAX_VALUE;\r\n    var len = points.length;\r\n    for (var i = 0; i < len; i++ ) {\r\n      // The magnitude of the projection of the point onto the normal\r\n      var dot = points[i].dot(normal);\r\n      if (dot < min) { min = dot; }\r\n      if (dot > max) { max = dot; }\r\n    }\r\n    result[0] = min; result[1] = max;\r\n  }\r\n  \r\n  // Check whether two convex polygons are separated by the specified\r\n  // axis (must be a unit vector).\r\n  /**\r\n   * @param {Vector} aPos The position of the first polygon.\r\n   * @param {Vector} bPos The position of the second polygon.\r\n   * @param {Array.<Vector>} aPoints The points in the first polygon.\r\n   * @param {Array.<Vector>} bPoints The points in the second polygon.\r\n   * @param {Vector} axis The axis (unit sized) to test against.  The points of both polygons\r\n   *   will be projected onto this axis.\r\n   * @param {Response=} response A Response object (optional) which will be populated\r\n   *   if the axis is not a separating axis.\r\n   * @return {boolean} true if it is a separating axis, false otherwise.  If false,\r\n   *   and a response is passed in, information about how much overlap and\r\n   *   the direction of the overlap will be populated.\r\n   */\r\n  function isSeparatingAxis(aPos, bPos, aPoints, bPoints, axis, response) {\r\n    var rangeA = T_ARRAYS.pop();\r\n    var rangeB = T_ARRAYS.pop();\r\n    // The magnitude of the offset between the two polygons\r\n    var offsetV = T_VECTORS.pop().copy(bPos).sub(aPos);\r\n    var projectedOffset = offsetV.dot(axis);\r\n    // Project the polygons onto the axis.\r\n    flattenPointsOn(aPoints, axis, rangeA);\r\n    flattenPointsOn(bPoints, axis, rangeB);\r\n    // Move B's range to its position relative to A.\r\n    rangeB[0] += projectedOffset;\r\n    rangeB[1] += projectedOffset;\r\n    // Check if there is a gap. If there is, this is a separating axis and we can stop\r\n    if (rangeA[0] > rangeB[1] || rangeB[0] > rangeA[1]) {\r\n      T_VECTORS.push(offsetV); \r\n      T_ARRAYS.push(rangeA); \r\n      T_ARRAYS.push(rangeB);\r\n      return true;\r\n    }\r\n    // This is not a separating axis. If we're calculating a response, calculate the overlap.\r\n    if (response) {\r\n      var overlap = 0;\r\n      // A starts further left than B\r\n      if (rangeA[0] < rangeB[0]) {\r\n        response['aInB'] = false;\r\n        // A ends before B does. We have to pull A out of B\r\n        if (rangeA[1] < rangeB[1]) { \r\n          overlap = rangeA[1] - rangeB[0];\r\n          response['bInA'] = false;\r\n        // B is fully inside A.  Pick the shortest way out.\r\n        } else {\r\n          var option1 = rangeA[1] - rangeB[0];\r\n          var option2 = rangeB[1] - rangeA[0];\r\n          overlap = option1 < option2 ? option1 : -option2;\r\n        }\r\n      // B starts further left than A\r\n      } else {\r\n        response['bInA'] = false;\r\n        // B ends before A ends. We have to push A out of B\r\n        if (rangeA[1] > rangeB[1]) { \r\n          overlap = rangeA[0] - rangeB[1];\r\n          response['aInB'] = false;\r\n        // A is fully inside B.  Pick the shortest way out.\r\n        } else {\r\n          var option1 = rangeA[1] - rangeB[0];\r\n          var option2 = rangeB[1] - rangeA[0];\r\n          overlap = option1 < option2 ? option1 : -option2;\r\n        }\r\n      }\r\n      // If this is the smallest amount of overlap we've seen so far, set it as the minimum overlap.\r\n      var absOverlap = Math.abs(overlap);\r\n      if (absOverlap < response['overlap']) {\r\n        response['overlap'] = absOverlap;\r\n        response['overlapN'].copy(axis);\r\n        if (overlap < 0) {\r\n          response['overlapN'].reverse();\r\n        }\r\n      }      \r\n    }\r\n    T_VECTORS.push(offsetV); \r\n    T_ARRAYS.push(rangeA); \r\n    T_ARRAYS.push(rangeB);\r\n    return false;\r\n  }\r\n  \r\n  // Calculates which Vornoi region a point is on a line segment.\r\n  // It is assumed that both the line and the point are relative to `(0,0)`\r\n  //\r\n  //            |       (0)      |\r\n  //     (-1)  [S]--------------[E]  (1)\r\n  //            |       (0)      |\r\n  /**\r\n   * @param {Vector} line The line segment.\r\n   * @param {Vector} point The point.\r\n   * @return  {number} LEFT_VORNOI_REGION (-1) if it is the left region, \r\n   *          MIDDLE_VORNOI_REGION (0) if it is the middle region, \r\n   *          RIGHT_VORNOI_REGION (1) if it is the right region.\r\n   */\r\n  function vornoiRegion(line, point) {\r\n    var len2 = line.len2();\r\n    var dp = point.dot(line);\r\n    // If the point is beyond the start of the line, it is in the\r\n    // left vornoi region.\r\n    if (dp < 0) { return LEFT_VORNOI_REGION; }\r\n    // If the point is beyond the end of the line, it is in the\r\n    // right vornoi region.\r\n    else if (dp > len2) { return RIGHT_VORNOI_REGION; }\r\n    // Otherwise, it's in the middle one.\r\n    else { return MIDDLE_VORNOI_REGION; }\r\n  }\r\n  // Constants for Vornoi regions\r\n  /**\r\n   * @const\r\n   */\r\n  var LEFT_VORNOI_REGION = -1;\r\n  /**\r\n   * @const\r\n   */\r\n  var MIDDLE_VORNOI_REGION = 0;\r\n  /**\r\n   * @const\r\n   */\r\n  var RIGHT_VORNOI_REGION = 1;\r\n  \r\n  // ## Collision Tests\r\n\r\n  // Check if two circles collide.\r\n  /**\r\n   * @param {Circle} a The first circle.\r\n   * @param {Circle} b The second circle.\r\n   * @param {Response=} response Response object (optional) that will be populated if\r\n   *   the circles intersect.\r\n   * @return {boolean} true if the circles intersect, false if they don't. \r\n   */\r\n  function testCircleCircle(a, b, response) {\r\n    // Check if the distance between the centers of the two\r\n    // circles is greater than their combined radius.\r\n    var differenceV = T_VECTORS.pop().copy(b['pos']).sub(a['pos']);\r\n    var totalRadius = a['r'] + b['r'];\r\n    var totalRadiusSq = totalRadius * totalRadius;\r\n    var distanceSq = differenceV.len2();\r\n    // If the distance is bigger than the combined radius, they don't intersect.\r\n    if (distanceSq > totalRadiusSq) {\r\n      T_VECTORS.push(differenceV);\r\n      return false;\r\n    }\r\n    // They intersect.  If we're calculating a response, calculate the overlap.\r\n    if (response) { \r\n      var dist = Math.sqrt(distanceSq);\r\n      response['a'] = a;\r\n      response['b'] = b;\r\n      response['overlap'] = totalRadius - dist;\r\n      response['overlapN'].copy(differenceV.normalize());\r\n      response['overlapV'].copy(differenceV).scale(response['overlap']);\r\n      response['aInB']= a['r'] <= b['r'] && dist <= b['r'] - a['r'];\r\n      response['bInA'] = b['r'] <= a['r'] && dist <= a['r'] - b['r'];\r\n    }\r\n    T_VECTORS.push(differenceV);\r\n    return true;\r\n  }\r\n  SAT['testCircleCircle'] = testCircleCircle;\r\n  \r\n  // Check if a polygon and a circle collide.\r\n  /**\r\n   * @param {Polygon} polygon The polygon.\r\n   * @param {Circle} circle The circle.\r\n   * @param {Response=} response Response object (optional) that will be populated if\r\n   *   they interset.\r\n   * @return {boolean} true if they intersect, false if they don't.\r\n   */\r\n  function testPolygonCircle(polygon, circle, response) {\r\n    // Get the position of the circle relative to the polygon.\r\n    var circlePos = T_VECTORS.pop().copy(circle['pos']).sub(polygon['pos']);\r\n    var radius = circle['r'];\r\n    var radius2 = radius * radius;\r\n    var points = polygon['points'];\r\n    var len = points.length;\r\n    var edge = T_VECTORS.pop();\r\n    var point = T_VECTORS.pop();\r\n    \r\n    // For each edge in the polygon:\r\n    for (var i = 0; i < len; i++) {\r\n      var next = i === len - 1 ? 0 : i + 1;\r\n      var prev = i === 0 ? len - 1 : i - 1;\r\n      var overlap = 0;\r\n      var overlapN = null;\r\n      \r\n      // Get the edge.\r\n      edge.copy(polygon['edges'][i]);\r\n      // Calculate the center of the circle relative to the starting point of the edge.\r\n      point.copy(circlePos).sub(points[i]);\r\n      \r\n      // If the distance between the center of the circle and the point\r\n      // is bigger than the radius, the polygon is definitely not fully in\r\n      // the circle.\r\n      if (response && point.len2() > radius2) {\r\n        response['aInB'] = false;\r\n      }\r\n      \r\n      // Calculate which Vornoi region the center of the circle is in.\r\n      var region = vornoiRegion(edge, point);\r\n      // If it's the left region:\r\n      if (region === LEFT_VORNOI_REGION) { \r\n        // We need to make sure we're in the RIGHT_VORNOI_REGION of the previous edge.\r\n        edge.copy(polygon['edges'][prev]);\r\n        // Calculate the center of the circle relative the starting point of the previous edge\r\n        var point2 = T_VECTORS.pop().copy(circlePos).sub(points[prev]);\r\n        region = vornoiRegion(edge, point2);\r\n        if (region === RIGHT_VORNOI_REGION) {\r\n          // It's in the region we want.  Check if the circle intersects the point.\r\n          var dist = point.len();\r\n          if (dist > radius) {\r\n            // No intersection\r\n            T_VECTORS.push(circlePos); \r\n            T_VECTORS.push(edge);\r\n            T_VECTORS.push(point); \r\n            T_VECTORS.push(point2);\r\n            return false;\r\n          } else if (response) {\r\n            // It intersects, calculate the overlap.\r\n            response['bInA'] = false;\r\n            overlapN = point.normalize();\r\n            overlap = radius - dist;\r\n          }\r\n        }\r\n        T_VECTORS.push(point2);\r\n      // If it's the right region:\r\n      } else if (region === RIGHT_VORNOI_REGION) {\r\n        // We need to make sure we're in the left region on the next edge\r\n        edge.copy(polygon['edges'][next]);\r\n        // Calculate the center of the circle relative to the starting point of the next edge.\r\n        point.copy(circlePos).sub(points[next]);\r\n        region = vornoiRegion(edge, point);\r\n        if (region === LEFT_VORNOI_REGION) {\r\n          // It's in the region we want.  Check if the circle intersects the point.\r\n          var dist = point.len();\r\n          if (dist > radius) {\r\n            // No intersection\r\n            T_VECTORS.push(circlePos); \r\n            T_VECTORS.push(edge); \r\n            T_VECTORS.push(point);\r\n            return false;              \r\n          } else if (response) {\r\n            // It intersects, calculate the overlap.\r\n            response['bInA'] = false;\r\n            overlapN = point.normalize();\r\n            overlap = radius - dist;\r\n          }\r\n        }\r\n      // Otherwise, it's the middle region:\r\n      } else {\r\n        // Need to check if the circle is intersecting the edge,\r\n        // Change the edge into its \"edge normal\".\r\n        var normal = edge.perp().normalize();\r\n        // Find the perpendicular distance between the center of the \r\n        // circle and the edge.\r\n        var dist = point.dot(normal);\r\n        var distAbs = Math.abs(dist);\r\n        // If the circle is on the outside of the edge, there is no intersection.\r\n        if (dist > 0 && distAbs > radius) {\r\n          // No intersection\r\n          T_VECTORS.push(circlePos); \r\n          T_VECTORS.push(normal); \r\n          T_VECTORS.push(point);\r\n          return false;\r\n        } else if (response) {\r\n          // It intersects, calculate the overlap.\r\n          overlapN = normal;\r\n          overlap = radius - dist;\r\n          // If the center of the circle is on the outside of the edge, or part of the\r\n          // circle is on the outside, the circle is not fully inside the polygon.\r\n          if (dist >= 0 || overlap < 2 * radius) {\r\n            response['bInA'] = false;\r\n          }\r\n        }\r\n      }\r\n      \r\n      // If this is the smallest overlap we've seen, keep it. \r\n      // (overlapN may be null if the circle was in the wrong Vornoi region).\r\n      if (overlapN && response && Math.abs(overlap) < Math.abs(response['overlap'])) {\r\n        response['overlap'] = overlap;\r\n        response['overlapN'].copy(overlapN);\r\n      }\r\n    }\r\n    \r\n    // Calculate the final overlap vector - based on the smallest overlap.\r\n    if (response) {\r\n      response['a'] = polygon;\r\n      response['b'] = circle;\r\n      response['overlapV'].copy(response['overlapN']).scale(response['overlap']);\r\n    }\r\n    T_VECTORS.push(circlePos); \r\n    T_VECTORS.push(edge); \r\n    T_VECTORS.push(point);\r\n    return true;\r\n  }\r\n  SAT['testPolygonCircle'] = testPolygonCircle;\r\n  \r\n  // Check if a circle and a polygon collide.\r\n  //\r\n  // **NOTE:** This is slightly less efficient than polygonCircle as it just\r\n  // runs polygonCircle and reverses everything at the end.\r\n  /**\r\n   * @param {Circle} circle The circle.\r\n   * @param {Polygon} polygon The polygon.\r\n   * @param {Response=} response Response object (optional) that will be populated if\r\n   *   they interset.\r\n   * @return {boolean} true if they intersect, false if they don't.\r\n   */\r\n  function testCirclePolygon(circle, polygon, response) {\r\n    // Test the polygon against the circle.\r\n    var result = testPolygonCircle(polygon, circle, response);\r\n    if (result && response) {\r\n      // Swap A and B in the response.\r\n      var a = response['a'];\r\n      var aInB = response['aInB'];\r\n      response['overlapN'].reverse();\r\n      response['overlapV'].reverse();\r\n      response['a'] = response['b'];\r\n      response['b'] = a;\r\n      response['aInB'] = response['bInA'];\r\n      response['bInA'] = aInB;\r\n    }\r\n    return result;\r\n  }\r\n  SAT['testCirclePolygon'] = testCirclePolygon;\r\n  \r\n  // Checks whether polygons collide.\r\n  /**\r\n   * @param {Polygon} a The first polygon.\r\n   * @param {Polygon} b The second polygon.\r\n   * @param {Response=} response Response object (optional) that will be populated if\r\n   *   they interset.\r\n   * @return {boolean} true if they intersect, false if they don't.\r\n   */\r\n  function testPolygonPolygon(a, b, response) {\r\n    var aPoints = a['points'];\r\n    var aLen = aPoints.length;\r\n    var bPoints = b['points'];\r\n    var bLen = bPoints.length;\r\n    // If any of the edge normals of A is a separating axis, no intersection.\r\n    for (var i = 0; i < aLen; i++) {\r\n      if (isSeparatingAxis(a['pos'], b['pos'], aPoints, bPoints, a['normals'][i], response)) {\r\n        return false;\r\n      }\r\n    }\r\n    // If any of the edge normals of B is a separating axis, no intersection.\r\n    for (var i = 0;i < bLen; i++) {\r\n      if (isSeparatingAxis(a['pos'], b['pos'], aPoints, bPoints, b['normals'][i], response)) {\r\n        return false;\r\n      }\r\n    }\r\n    // Since none of the edge normals of A or B are a separating axis, there is an intersection\r\n    // and we've already calculated the smallest overlap (in isSeparatingAxis).  Calculate the\r\n    // final overlap vector.\r\n    if (response) {\r\n      response['a'] = a;\r\n      response['b'] = b;\r\n      response['overlapV'].copy(response['overlapN']).scale(response['overlap']);\r\n    }\r\n    return true;\r\n  }\r\n  SAT['testPolygonPolygon'] = testPolygonPolygon;\r\n\r\n  return SAT;\r\n}));",
    "/// <reference path=\"linker.js\" />\r\n\r\n/*\r\n    A place for generic math, set/get methods, and other small functions.\r\n    Also used for global data structures, enums, and functions.\r\n*/\r\nvar utils = (function () {\r\n    var cboxMenu;\r\n\r\n\r\n    return {\r\n        /*\r\n            extends an oldObj into a newObj\r\n            while keeping certain objects properties in sync\r\n        */\r\n        extend: function (newObj, oldObj) {\r\n            // merge-copy current oldObj into newObj\r\n            $.extend(newObj, oldObj);\r\n\r\n            // force newObj to get oldObj's imgReady property\r\n            var prop = \"imgReady\";\r\n            Object.defineProperty(newObj, prop, {\r\n                get: function () {\r\n                    return oldObj[prop];\r\n                },\r\n                //set: function (arg) {\r\n                //    oldObj[prop] = arg;\r\n                //},\r\n                //configurable: true\r\n            });\r\n\r\n        },\r\n\r\n        speed2scale: function(speed){\r\n            return -0.5*speed + 2;\r\n        },\r\n\r\n        /*\r\n            Returns a random float between a and b.\r\n\r\n            @param(number) min The min floating point number.\r\n            @param(number) max The max floating point number.\r\n            @param(?number) precision The number of decimal precision places. (2 (hundredths place) by default)\r\n        */\r\n        randF: function(min, max, precision){\r\n            if(typeof (precision) === \"undefined\") {\r\n                precision = 2; // hundredths place\r\n            }\r\n\r\n            return parseFloat(Math.min(min + (Math.random() * (max - min)), max).toFixed(precision));\r\n        },\r\n\r\n        repeatAction: function (timeStep, numTimes, callback) {\r\n            var num = 0;\r\n            var theAnimation = setInterval(function () {\r\n                if (num++ > numTimes) {\r\n                    clearInterval(theAnimation);\r\n                }\r\n                else {\r\n                    callback();\r\n                }\r\n            }, timeStep);\r\n        },\r\n\r\n        deathSequence: function(){\r\n            if (!game.over) {\r\n                game.over = true;\r\n\r\n                audio.heroDeath.play();\r\n                audio.bgMusic.muted = true;\r\n\r\n                setTimeout(function () {\r\n                    Graphics.fadeCanvas(function() {\r\n                        if((hero.lives - 1) < 0) {\r\n                            alert(\"You Lose\");\r\n                            location.reload();\r\n                        }\r\n                        else {\r\n                            --hero.lives;\r\n                        }\r\n\r\n\r\n                        level.reset();\r\n                        level.curLvl.deinit();\r\n                        level.curLvl.init();\r\n\r\n                        if (audio.isOn)\r\n                            audio.bgMusic.muted = false;\r\n                    });\r\n                }, 2600);\r\n            }\r\n        },\r\n\r\n        degToRad: function(deg){\r\n            return deg * 0.0174532925199432957;\r\n        },\r\n\r\n        revFactorial: function(n){\r\n            var count = 2;\r\n            var result = n;\r\n\r\n            while(result !== 1) {\r\n                console.log(result + '/' + count + '=');\r\n                result /= count;\r\n\r\n                if(result === 0) {\r\n                    return -1;\r\n                }\r\n                else if(result === 1) {\r\n                    return count;\r\n                }\r\n                else {\r\n                    ++count;\r\n                }\r\n            }\r\n        },\r\n\r\n        getTimeObj: function (t) {\r\n            if (t === 0) {\r\n                return { min: \"00\", sec: \"00\" };\r\n            }\r\n            \r\n            var min = Math.floor(t / 60);\r\n            var sec = t % 60;\r\n\r\n            if (sec < 10) {\r\n                sec = '0' + sec;\r\n            }\r\n\r\n            if (min < 10) {\r\n                min = '0' + min;\r\n            }\r\n\r\n            return {\r\n                min: min,\r\n                sec: sec\r\n            };\r\n        },\r\n\r\n        browser: function(){\r\n            var ua = navigator.userAgent,\r\n                     tem,\r\n                     M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\\/))\\/?\\s*([\\d\\.]+)/i) || []\r\n            ;\r\n\r\n            if (/trident/i.test(M[1])) {\r\n                tem = /\\brv[ :]+(\\d+(\\.\\d+)?)/g.exec(ua) || [];\r\n                    return 'IE '+(tem[1] || '');\r\n            }\r\n\r\n            M = M[2]? [M[1], M[2]]:[navigator.appName, navigator.appVersion, '-?'];\r\n\r\n            if ((tem = ua.match(/version\\/([\\.\\d]+)/i)) != null)\r\n                M[2] = tem[1];\r\n\r\n            return M.join(' ');\r\n        },\r\n\r\n        /**** Debug Printers ****/\r\n        // A method to print to the console less frequently then within the game loop.\r\n        printSlow: function(msg){\r\n            if (game.actualTime % 10 === 0) {\r\n                console.log(msg);\r\n            }\r\n        },\r\n\r\n\t\tprintMouse: function () {\r\n\t\t    $(\"canvas\").on(\"mousemove\", function (e) {\r\n\t\t        console.log(e.offsetX, e.offsetY);\r\n\t\t    });\r\n\t\t},\r\n\r\n\t\tprintDir: function (dir) {\r\n\t\t    switch (dir) {\r\n\t\t        case 0:\r\n\t\t            console.log(\"Dir.NONE\");\r\n\t\t            break;\r\n\t\t        case 1:\r\n\t\t            console.log(\"Dir.TOP\");\r\n\t\t            break;\r\n\t\t        case 2:\r\n\t\t            console.log(\"Dir.BOT\");\r\n\t\t            break;\r\n\t\t        case 3:\r\n\t\t            console.log(\"Dir.LEFT\");\r\n\t\t            break;\r\n\t\t        case 4:\r\n\t\t            console.log(\"Dir.RIGHT\");\r\n\t\t            break;\r\n\t\t        case 5:\r\n\t\t            console.log(\"Dir.IN\");\r\n\t\t            break;\r\n\t\t        default:\r\n\t\t            console.log(\"Dir.unknown\");\r\n\t\t    }\r\n\t\t},\r\n\r\n\t\ttoggleMenu: function () {\r\n\r\n\t\t    if ($(\"#colorbox\").css(\"display\") === \"block\") {\r\n\t\t        cboxMenu.colorbox.close();\r\n\t\t    }\r\n\t\t    else {\r\n\t\t        cboxMenu = $.colorbox({\r\n\t\t            html: $(\".gameInstructions\").html(),\r\n\t\t            width: 320,\r\n\t\t            height: 530\r\n\t\t        });\r\n\t\t    }\r\n\t\t},\r\n\r\n\t\ttoggleFullScreen: function () {\r\n\r\n\r\n\t\t    // fill browser window\r\n\t\t    if ($(\"body\").hasClass(\"fullscreen\")) {\r\n\t\t        $(\".canvasWrap\").css({\r\n\t\t            width: \"\",\r\n\t\t            marginLeft: \"\"\r\n\t\t        });\r\n\r\n\t\t        $(\"body\").removeClass(\"fullscreen\");\r\n\t\t    }\r\n\t\t    else {\r\n\t\t        $(\"body\").addClass(\"fullscreen\");\r\n\r\n\t\t        var scaledW = $(window).height() * 1.777778;\r\n\r\n\t\t        $(\".canvasWrap\").css({\r\n\t\t            width: scaledW,\r\n\t\t            marginLeft: -scaledW / 2\r\n\t\t        });\r\n\t\t    }\r\n\r\n\r\n\r\n            // fullscreen API\r\n            //if (!document.fullscreenElement &&    // alternative standard method\r\n            //    !document.mozFullScreenElement && !document.webkitFullscreenElement) {  // current working methods\r\n\r\n            //    if (canvas.requestFullscreen) {\r\n            //        canvas.requestFullscreen();\r\n            //    }\r\n            //    else if (canvas.mozRequestFullScreen) {\r\n            //        canvas.mozRequestFullScreen();\r\n            //    }\r\n            //    else if (canvas.webkitRequestFullscreen) {\r\n            //        canvas.webkitRequestFullscreen(); //Element.ALLOW_KEYBOARD_INPUT\r\n            //    }\r\n            //}\r\n            //else {\r\n            //    if (document.cancelFullScreen) {\r\n            //        document.cancelFullScreen();\r\n            //    }\r\n            //    else if (document.mozCancelFullScreen) {\r\n            //        document.mozCancelFullScreen();\r\n            //    }\r\n            //    else if (document.webkitCancelFullScreen) {\r\n            //        document.webkitCancelFullScreen();\r\n            //    }\r\n            //}\r\n        }\r\n\r\n\t};\r\n})();\r\n\r\n\r\n// global enums\r\nvar Dir = Object.freeze({\r\n    NONE: 0,\r\n    TOP: 1,\r\n    BOT: 2,\r\n    LEFT: 3,\r\n    RIGHT: 4,\r\n    IN: 5,\r\n    UP: 6,\r\n    DOWN: 7,\r\n    UP_RIGHT: 8,\r\n    DOWN_RIGHT: 9\r\n});\r\n\r\nvar Color = Object.freeze({\r\n    LIGHT_BROWN: \"#c44525\",\r\n    DARK_BROWN: \"#672819\",\r\n    LIGHT_GREEN: \"#166a38\",\r\n    SILVER: \"#c0c0c0\",\r\n    BLACK: \"#000\",\r\n    GOLD: \"#ddaa13\",\r\n    ORANGE: \"#ff6a00\"\r\n});\r\n\r\n// global functions\r\nwindow.requestAnimFrame = (function () {\r\n    return window.requestAnimationFrame ||\r\n\t\t   window.webkitRequestAnimationFrame ||\r\n\r\n\t\t   function (callback) {\r\n\t\t       setTimeout(callback, 16.6666666667); // 60fps fallback\r\n\t\t   };\r\n})();\r\n",
    "var audio = (function () {\r\n\r\n    return {\r\n        bgMusic: new Audio(\"audio/firstChiptune/firstChiptune.mp3\"),\r\n        enterSound: new Audio(\"audio/synthetic_explosion_1.mp3\"),\r\n        exitSound: new Audio(\"audio/annulet.mp3\"),\r\n        itemPickedUp: new Audio(\"audio/life_pickup.mp3\"),\r\n        heartbeat: new Audio(\"audio/heartbeat.mp3\"),\r\n        jump: new Audio(\"audio/jump.mp3\"),\r\n        thud: new Audio(\"audio/thud.mp3\"),\r\n        step: new Audio(\"audio/step.mp3\"),\r\n        effort: new Audio(\"audio/woosh.mp3\"),\r\n        discovery: new Audio(\"audio/spell3.mp3\"),\r\n        enemyDeath: new Audio(\"audio/death.mp3\"),\r\n        heroDeath: new Audio(\"audio/DiscsOfTron_Cascade.mp3\"),\r\n        enchant: new Audio(\"audio/enchant.mp3\"),\r\n        isOn: false,\r\n\r\n\r\n        init: function(){\r\n            audio.bgMusic.loop = true;\r\n            audio.bgMusic.volume = 0.7;\r\n            audio.bgMusic.pause();\r\n\r\n            audio.enemyDeath.volume = 0.6;\r\n            audio.jump.volume = 0.4;\r\n            audio.thud.volume = 0.78;\r\n            audio.discovery.volume = 0.7;\r\n\r\n            audio.mute(true);\r\n            $(document).on(\"click\", \".audioState\", audio.handleMuteButton);\r\n\r\n            $(\".menu\").on(\"click\", function (e) {\r\n                e.preventDefault();\r\n                utils.toggleMenu();\r\n            })\r\n\r\n            //----- enable audio on start -----\r\n            audio.handleMuteButton()\r\n        },\r\n\r\n        lvlComplete: function () {\r\n            audio.bgMusic.pause();\r\n\r\n            var newBgMusic;\r\n            \r\n            switch(game.lvl) {\r\n                case 0:\r\n                    audio.enterSound.play();\r\n                    newBgMusic = \"inspiredBySparkMan/sparkBoy.mp3\";\r\n                    break;\r\n                default:\r\n                    audio.exitSound.play();\r\n                    newBgMusic = \"sweetAcoustic.mp3\";\r\n                    break;\r\n            }\r\n\r\n            setTimeout(function () {\r\n                audio.bgMusic = new Audio(\"audio/\" + newBgMusic);\r\n                audio.bgMusic.loop = true;\r\n                audio.bgMusic.volume = 0.45;\r\n\r\n                audio.isOn ?\r\n                    audio.bgMusic.play() :\r\n                    audio.bgMusic.pause();\r\n            }, 1000);\r\n        },\r\n\r\n        play: function (sound, stopPrev) {\r\n            stopPrev = (typeof (stopPrev) !== \"undefined\") ? stopPrev : true;\r\n\r\n            if (sound.ended)\r\n                sound.play();\r\n            else {\r\n                if (stopPrev || sound.currentTime === 0) {\r\n                    sound.pause();\r\n                    sound.currentTime = 0;\r\n                    sound.play();\r\n                }\r\n            }\r\n        },\r\n\r\n        handleMuteButton: function () {\r\n            if ($('.audioState').hasClass('off')) {\r\n                $('.audioState span').removeClass('icon-volume-mute').addClass('icon-volume-medium');\r\n                $('.audioState').removeClass('off');\r\n                $('.audioState').addClass('on');\r\n\r\n                audio.mute(false);\r\n            }\r\n            else {\r\n                $('.audioState span').removeClass('icon-volume-medium').addClass('icon-volume-mute');\r\n                $('.audioState').removeClass('on');\r\n                $('.audioState').addClass('off');\r\n\r\n                audio.mute(true);\r\n            }\r\n        },\r\n\r\n        mute: function (onOrOff) {\r\n            audio.discovery.muted =\r\n            audio.enterSound.muted =\r\n            audio.bgMusic.muted =\r\n            audio.itemPickedUp.muted =\r\n            audio.heartbeat.muted =\r\n            audio.effort.muted = \r\n            audio.thud.muted = \r\n            audio.jump.muted = \r\n            audio.step.muted = \r\n            audio.enemyDeath.muted =\r\n            audio.heroDeath.muted =\r\n            audio.enchant.muted =\r\n            audio.exitSound.muted =\r\n                onOrOff;\r\n\r\n            onOrOff ?\r\n                audio.bgMusic.pause() :\r\n                audio.bgMusic.play();\r\n\r\n            audio.isOn = !onOrOff;\r\n        }\r\n    };\r\n})();\r\n",
    "/// <reference path=\"../linker.js\" />\r\n\r\n/*\r\n    A library of generic graphics functions.\r\n*/\r\nvar Graphics = (function () {\r\n\r\n    var alpha = 1,\r\n        canvasTransition = null,\r\n        swellN = 250,\r\n        swellTimer = swellN,\r\n        swellRadius = swellN,\r\n        cloundMaxY = 170\r\n    ;\r\n\r\n    return {\r\n        ticker: 1,              // 1.0 --> 0.0 --> 1.0 --> ...\r\n        tickerStep: 0.01,\r\n        fadeOut: false,\r\n        projectX: 8,\r\n        projectY: 11,\r\n\r\n\r\n        fadeCanvas: function (callback) {\r\n            if (utils.browser() === \"MSIE 9.0\") {\r\n                callback();\r\n            }\r\n            else {\r\n                $(canvas).removeClass(\"preTransition\");\r\n                $(canvas).addClass(\"duringTransition\");\r\n\r\n                canvasTransition = $(canvas).on(\"transitionend webkitTransitionEnd oTransitionEnd MSTransitionEnd\", function () {\r\n                    canvasTransition.off();\r\n\r\n                    $(this).removeClass(\"duringTransition\");\r\n                    $(this).addClass(\"preTransition\");\r\n\r\n                    callback();\r\n                });\r\n            }\r\n        },\r\n\r\n        blinkText: function (fontSize, x, y, str) {\r\n            str = (typeof (str) !== \"undefined\") ? str : \"PRESS ENTER\";\r\n\r\n            if (Graphics.ticker >= 1.35 || Graphics.ticker <= Graphics.tickerStep) {\r\n                Graphics.fadeOut = !Graphics.fadeOut;\r\n            }\r\n\r\n            if (Graphics.ticker >= 1) {\r\n                alpha = 1;\r\n            }\r\n            else if (Graphics.ticker <= Graphics.tickerStep) {\r\n                alpha = 0;\r\n            }\r\n            else {\r\n                alpha = Graphics.ticker;\r\n            }\r\n\r\n            ctx.font = fontSize + \"px 'Press Start 2P'\";\r\n            var tmpW = ctx.measureText(str).width;\r\n            ctx.fillStyle = \"rgba(233, 233, 233,\" + alpha + ')';\r\n            ctx.fillText(str, x - tmpW / 2, y);\r\n        },\r\n\r\n        /*\r\n            Converts a rectangle into a 'skewed rectangle' polygon\r\n\r\n            @param(number) x\r\n            @param(number) y\r\n            @param(number) w\r\n            @param(number) h\r\n            @return (SAT.Polygon)\r\n        */\r\n        getSkewedRect: function (x, y, w, h) {\r\n            y += Graphics.projectY / 2;\r\n\r\n            var poly = new SAT.Polygon(new SAT.Vector(x, y), [\r\n                new SAT.Vector(),\r\n                new SAT.Vector(w - Graphics.projectX, 0),\r\n                new SAT.Vector(w, Graphics.projectY),\r\n                new SAT.Vector(w, h),\r\n                new SAT.Vector(Graphics.projectX, h),\r\n                new SAT.Vector(0, h - Graphics.projectY)\r\n            ]);\r\n\r\n            return poly;\r\n        },\r\n\r\n        getStairPoly: function(x, y, w, h, dir) {\r\n            var poly;\r\n            if(dir === Dir.UP_RIGHT) {\r\n                poly = new SAT.Polygon(new SAT.Vector(x, y), [\r\n                    new SAT.Vector(),\r\n                    new SAT.Vector(w - Graphics.projectX, -h),\r\n                    new SAT.Vector(w, -h + Graphics.projectY),\r\n                    new SAT.Vector(w, 0),\r\n                    new SAT.Vector(Graphics.projectX, h),\r\n                    new SAT.Vector(0, h - Graphics.projectY)\r\n                ]);\r\n            }\r\n            else {\r\n                poly = new SAT.Polygon(new SAT.Vector(x, y), [\r\n                    new SAT.Vector(),\r\n                    new SAT.Vector(w - Graphics.projectX, h - Graphics.projectY - 5),\r\n                    new SAT.Vector(w, h - 4),\r\n                    new SAT.Vector(0, h),\r\n                    new SAT.Vector(Graphics.projectX, h),\r\n                    new SAT.Vector(0, h - Graphics.projectY)\r\n                ]);\r\n            }\r\n\r\n            return poly;\r\n        },\r\n\r\n        setClouds: function(width){\r\n            var x = 0;\r\n            \r\n            while(x < width) {\r\n                x = Graphics.spawnCloud(x);\r\n            }\r\n        },\r\n\r\n        spawnCloud: function (x) {\r\n            var y = Math.floor(Math.random() * cloundMaxY);\r\n            var speed = utils.randF(2, 3.3, 1);\r\n            var width = utils.speed2scale(speed) * 120; // 120px is clound.png width; TODO: fix GameObj image width calculation\r\n\r\n            x += width + Math.floor((Math.random() * 20) + 8);\r\n\r\n            var obj = new GameObj(JQObject.CLOUD, x, 10 + y, 0, 0, \"cloud.png\");\r\n            obj.speed = speed;\r\n            obj.distTraveled = 0;\r\n            obj.distToTravel = x + width;\r\n\r\n            level.bg.push(obj);\r\n\r\n            return x;\r\n        },\r\n\r\n        drawLadder: function (platform) {\r\n            var x = platform.pos.x,\r\n                y = platform.pos.y,\r\n                w = platform.edges[0].x,\r\n                h = platform.edges[1].y\r\n            ;\r\n\r\n            // sides\r\n            ctx.fillStyle = Color.LIGHT_BROWN;\r\n            ctx.fillRect(x, y, 5, h);\r\n            ctx.fillRect(x + w-5, y, 5, h);\r\n\r\n            // rungs\r\n            for (var i = 13; i < h; i+=20) {\r\n                ctx.fillRect(x, y+i, w, 8);\r\n            }\r\n        },\r\n\r\n        getScale: function(x, y) {\r\n            var theScale = {};\r\n\r\n            for(var i = 0; i < 2; ++i) {\r\n                var dir = (i === 0) ? Dir.LEFT : Dir.RIGHT;\r\n\r\n                theScale[dir] = new GameObj(JQObject.SCALE, x + i * 300, y, 150, 46);\r\n                theScale[dir].holdingItem = null; // TODO: fix api\r\n            }\r\n\r\n            theScale.vBar = new GameObj(JQObject.SCALEBG,\r\n                theScale[Dir.LEFT].pos.x + theScale[Dir.LEFT].w + 70,\r\n                HALFH - game.padFloor,\r\n                10,\r\n                HALFH\r\n            );\r\n            theScale.vBar.collidable = false;\r\n\r\n            theScale.hBar = new GameObj(JQObject.SCALEBG,\r\n                theScale[Dir.LEFT].pos.x + theScale[Dir.LEFT].w / 2,\r\n                HALFH,\r\n                300,\r\n                10\r\n            );\r\n            theScale.hBar.x2 = theScale.hBar.pos.x + theScale.hBar.w;\r\n            theScale.hBar.y2 = theScale.hBar.pos.y;\r\n            theScale.hBar.collidable = false;\r\n            theScale.hBar.visible = false;\r\n\r\n            theScale[Dir.LEFT].hBar = theScale.hBar;\r\n            theScale[Dir.LEFT].side = Dir.LEFT;\r\n            theScale[Dir.LEFT].otherSide = theScale[Dir.RIGHT];\r\n\r\n            theScale[Dir.RIGHT].hBar = theScale.hBar;\r\n            theScale[Dir.RIGHT].side = Dir.RIGHT;\r\n            theScale[Dir.RIGHT].otherSide = theScale[Dir.LEFT];\r\n\r\n            return theScale;\r\n        },\r\n\r\n        drawScale: function (platform) {\r\n            var x = platform.pos.x,\r\n                y = platform.pos.y,\r\n                w = platform.edges[0].x,\r\n                h = platform.edges[1].y\r\n            ;\r\n            \r\n            // draw top border 1px above bounding box\r\n            ctx.fillStyle = Color.BLACK;\r\n            ctx.fillRect(x, y - 1, w, 1);\r\n\r\n            // draw platform\r\n            ctx.fillStyle = Color.DARK_BROWN;\r\n            ctx.fillRect(x, y, w, h);\r\n        },\r\n\r\n        drawScaleChains:function(x, y, scale) {\r\n            ctx.beginPath();\r\n            ctx.moveTo(x, y);\r\n            ctx.lineTo(scale.pos.x, scale.pos.y);\r\n            ctx.stroke();\r\n            ctx.closePath();\r\n\r\n            ctx.beginPath();\r\n            ctx.moveTo(x, y);\r\n            ctx.lineTo(scale.pos.x + scale.w / 2, scale.pos.y);\r\n            ctx.stroke();\r\n            ctx.closePath();\r\n\r\n            ctx.beginPath();\r\n            ctx.moveTo(x, y);\r\n            ctx.lineTo(scale.pos.x + scale.w, scale.pos.y);\r\n            ctx.stroke();\r\n            ctx.closePath();\r\n        },\r\n\r\n        drawScaleBg: function(theScale){\r\n            ctx.strokeStyle = \"#000\";\r\n            ctx.lineWidth = 10;\r\n\r\n            // hBar\r\n            ctx.beginPath();\r\n            ctx.moveTo(theScale.hBar.pos.x, theScale.hBar.pos.y);\r\n            ctx.lineTo(theScale.hBar.x2, theScale.hBar.y2);\r\n            ctx.stroke();\r\n            ctx.closePath();\r\n            \r\n            // left scale chains\r\n            Graphics.drawScaleChains(theScale.hBar.pos.x, theScale.hBar.pos.y, theScale[Dir.LEFT]);\r\n\r\n            // right scale chains\r\n            Graphics.drawScaleChains(theScale.hBar.x2, theScale.hBar.y2, theScale[Dir.RIGHT]);\r\n        },\r\n\r\n        /*\r\n            @param(SAT.Polygon) poly An SAT.Polygon.\r\n            @param(?Color) fillStyle The fill style of the polygon\r\n            @param(?number, ?number) trans A translated x and y dimension.\r\n        */\r\n        drawPoly: function(poly, fillStyle, trans) {\r\n            var y = poly.pos.y - Graphics.projectY;\r\n            var x = poly.pos.x;\r\n\r\n            if(typeof (trans) !== \"undefined\") {\r\n                x += trans.x;\r\n                y += trans.y;\r\n            }\r\n\r\n            ctx.fillStyle = (typeof(fillStyle) !== \"undefined\") ? fillStyle : \"orange\";\r\n            ctx.beginPath();\r\n            ctx.moveTo(x, y);\r\n\r\n            for(var i = 1; i < poly.points.length; ++i) {\r\n                ctx.lineTo(x + poly.points[i].x, y + poly.points[i].y);\r\n            }\r\n\r\n            ctx.closePath();\r\n            ctx.fill();\r\n        },\r\n\r\n        drawHill: function(poly) {\r\n            for(var i = 0; i < game.padFloor - 15; ++i) {\r\n                Graphics.drawPoly(poly, Color.LIGHT_BROWN, { x: 0, y: i });\r\n            }\r\n            Graphics.drawPoly(poly, Color.DARK_BROWN, { x: Graphics.projectX, y: game.padFloor});\r\n            //Graphics.drawPoly(poly, Color.DARK_BROWN, { x: 10, y: game.padFloor -2 });\r\n        },\r\n\r\n        getHill: function(x, y, w, h) {\r\n            var arr = [new SAT.V()];\r\n\r\n            x += w / 2;\r\n            y += Graphics.projectY;\r\n\r\n            var a = w / 2,  // the horizontal radius\r\n                b = h / 2,  // the vertical radius\r\n                t = 180,    // the angle between the horizontal radius and a vector to any point on the curve (in degrees)\r\n                xx,\r\n                yy\r\n            ;\r\n\r\n            while(t !== 360) {\r\n                xx = a * Math.cos(utils.degToRad(t));\r\n                yy = b * Math.sin(utils.degToRad(t++));\r\n                arr.push(new SAT.V(xx, yy));\r\n            }\r\n\r\n            arr.push(new SAT.V(w/2));\r\n\r\n            return new SAT.Polygon(new SAT.V(x, y), arr);\r\n        },\r\n\r\n        drawPlatform: function (poly) {\r\n            var y = poly.pos.y - Graphics.projectY / 2;\r\n\r\n            // top\r\n            ctx.fillStyle = Color.LIGHT_BROWN;\r\n            ctx.beginPath();\r\n            ctx.moveTo(poly.pos.x, y);\r\n            ctx.lineTo(poly.pos.x + poly.points[1].x, y + poly.points[1].y);\r\n            ctx.lineTo(poly.pos.x + poly.points[2].x, y + poly.points[2].y);\r\n            ctx.lineTo(poly.pos.x + Graphics.projectX, y + Graphics.projectY);\r\n            ctx.closePath();\r\n            ctx.fill();\r\n\r\n            // body\r\n            ctx.fillStyle = Color.DARK_BROWN;\r\n            ctx.beginPath();\r\n            ctx.moveTo(poly.pos.x + poly.points[2].x, y + poly.points[2].y);\r\n            ctx.lineTo(poly.pos.x + poly.points[3].x, y + poly.points[3].y);\r\n            ctx.lineTo(poly.pos.x + poly.points[4].x, y + poly.points[4].y);\r\n            ctx.lineTo(poly.pos.x + poly.points[5].x, y + poly.points[5].y);\r\n            ctx.lineTo(poly.pos.x + poly.points[0].x, y + poly.points[0].y);\r\n            ctx.lineTo(poly.pos.x + Graphics.projectX, y + Graphics.projectY);\r\n            ctx.closePath();\r\n            ctx.fill();\r\n        },\r\n\r\n        drawPlatformStatus: function (platform) {\r\n            var x = platform.pos.x,\r\n                y = platform.pos.y,\r\n                w = platform.w,\r\n                h = platform.h,\r\n                theShape = 26,\r\n                halfTheShape = theShape/2,\r\n                midX = x + w/2 - halfTheShape,\r\n                midY = y + h/2 - halfTheShape\r\n            ;\r\n\r\n            ctx.lineWidth = 3;\r\n\r\n            if (platform.holdingItem !== null && platform.holdingItem.type === JQObject.CRATE) {\r\n                // draw check mark\r\n                ctx.strokeStyle = \"green\";\r\n\r\n                --midY;\r\n                ctx.beginPath();\r\n                ctx.moveTo(midX, midY + halfTheShape);\r\n                ctx.lineTo(midX + halfTheShape, midY + theShape);\r\n                ctx.moveTo(midX + halfTheShape-1, midY + theShape);\r\n                ctx.lineTo(midX + theShape+2, midY+2);\r\n                ctx.stroke();\r\n                ctx.closePath();\r\n\r\n            }\r\n            else {\r\n                // draw 'X'\r\n                ctx.strokeStyle = \"red\";\r\n\r\n                ctx.beginPath();\r\n                ctx.moveTo(midX, midY);\r\n                ctx.lineTo(midX + theShape, midY + theShape);\r\n                ctx.moveTo(midX, midY + theShape);\r\n                ctx.lineTo(midX + theShape, midY);\r\n                ctx.stroke();\r\n                ctx.closePath();\r\n            }\r\n        },\r\n\r\n        // @param(GameObj) gObj A game object.\r\n        drawDoor: function (gObj) {\r\n            // alias\r\n            var x = gObj.pos.x;\r\n            var y = gObj.pos.y;\r\n            var w = gObj.w;\r\n            var h = gObj.h;\r\n\r\n            // door\r\n            ctx.fillStyle = Color.LIGHT_BROWN;\r\n            ctx.fillRect(x + 2, y + 2, w - 2, h - 2);\r\n\r\n            ctx.fillStyle = Color.DARK_BROWN;\r\n\r\n            ctx.fillRect(x, y, 2, h);   // left frame\r\n            ctx.fillRect(x, y, w, 2);   // top frame\r\n            ctx.fillRect(x + w, y, 2, h);   // right frame\r\n\r\n            // door handle\r\n            ctx.beginPath();\r\n            ctx.arc(x + w - (w / 3.2), y + h - (h / 3.4), 4, 0, 2 * Math.PI, false);\r\n            ctx.fill();\r\n            ctx.closePath();\r\n\r\n            // label\r\n            ctx.font = \"19px 'Press Start 2P'\";\r\n            ctx.fillStyle = Color.DARK_BROWN;\r\n            ctx.fillText(\"EXIT\", x - 15, y - 3);\r\n            ctx.fillStyle = Color.LIGHT_BROWN;\r\n            ctx.fillText(\"EXIT\", x - 18, y - 5);\r\n        },\r\n\r\n        getDoorBgGrad: function(){\r\n            var grad = ctx.createRadialGradient(\r\n                level.bgColor.gradX,\r\n                level.bgColor.gradY,\r\n                14,\r\n                level.bgColor.gradX,\r\n                level.bgColor.gradY,\r\n                490 - swellRadius\r\n            );\r\n\r\n            if(--swellTimer === -swellN) {\r\n                swellTimer = swellN;\r\n                swellRadius = swellN;\r\n            }\r\n            else if(swellTimer < 0) {\r\n                ++swellRadius;\r\n            }\r\n            else {\r\n                --swellRadius;\r\n            }\r\n\r\n            grad.addColorStop(0, \"rgb(203,163,0)\");\r\n            //grad.addColorStop(0, \"rgb(42,126,76)\");\r\n            //grad.addColorStop(1, \"rgb(22,106,56)\");\r\n            grad.addColorStop(1, \"#1F7DCF\");\r\n\r\n            return grad;\r\n        },\r\n\r\n        drawEllipse: function (x, y, w, h) {\r\n            var kappa = 0.5522848,\r\n\t\t\t\tox = (w / 2) * kappa, // control point offset horizontal\r\n\t\t\t\toy = (h / 2) * kappa, // control point offset vertical\r\n\t\t\t\txe = x + w, // x-end\r\n\t\t\t\tye = y + h, // y-end\r\n\t\t\t\txm = x + w / 2, // x-middle\r\n\t\t\t\tym = y + h / 2 // y-middle\r\n            ;\r\n\r\n            ctx.beginPath();\r\n            ctx.moveTo(x, ym);\r\n            ctx.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y);\r\n            ctx.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym);\r\n            ctx.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);\r\n            ctx.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);\r\n            ctx.closePath();\r\n            ctx.fill();\r\n        },\r\n\r\n        drawRotate: function (img, x, y, angle) {\r\n            ctx.save();\r\n\r\n            ctx.translate(x, y);\t\t\t\t\t\t\t\t// move co-ord sys to img origin\r\n            ctx.rotate(utils.degToRad(angle));\r\n            ctx.translate(-img.width * 0.5, -img.height * 0.5); // move to top left of img\r\n\r\n            //ctx.scale(0.75, 0.75);\r\n            ctx.drawImage(img, 0, 0);\r\n\r\n            ctx.restore();\r\n        }\r\n    };\r\n})();\r\n\r\n\r\n/* Images */\r\n//lvl = new Array(NUM_LEVELS),\r\n//lvlBgImg = {}\r\n//function loadBgImages(imgArr, callback) {\r\n//    var count = 0;\r\n\r\n//    for (var key in imgArr) {\r\n//        if (imgArr[key] !== \"none\") {\r\n//            lvlBgImg[key] = new Image();\r\n//            lvlBgImg[key].onload = function () {\r\n//                callback(this.num);\r\n//            };\r\n\r\n//            lvlBgImg[key].src = imgArr[key];\r\n//            lvlBgImg[key].num = count;\r\n//        }\r\n\r\n//        ++count;\r\n//    }\r\n//}\r\n\r\n//for (var i = 0; i < NUM_LEVELS; ++i) {\r\n//    lvl[i] = {\r\n//        status: false,\r\n//        bgColor: '#' + Math.floor(Math.random() * 16777215).toString(16)\r\n//    };\r\n//}\r\n\r\n//loadBgImages({\r\n//    lvl0: \"img/lvl0.jpg\",\r\n//    lvl1: \"none\"\r\n//}, function (num) {\r\n//    lvl[num].status = true;\r\n//});\r\n\r\n\r\n\r\n\r\n//var wasClicked = false;\r\n//$(\".resize\").on(\"click\", function(){\r\n//    if (wasClicked) {\r\n//        $(canvas).css({ width: \"\", height: \"\" });\r\n//        $(this).attr(\"class\", \"resize off\");\r\n//        $(this).children(\"span\").attr(\"class\", \"icon-expand\");\r\n//    }\r\n//    else {\r\n//        $(canvas).css({ width: \"100%\" });\r\n\r\n//        // fix for IE\r\n//        var width = $(canvas).width();\r\n//        $(canvas).css({ height: 0.611 * width });\r\n\r\n\r\n//        $(this).attr(\"class\", \"resize on\");\r\n//        $(this).children(\"span\").attr(\"class\", \"icon-contract\");\r\n//    }\r\n\r\n//    wasClicked = !wasClicked;\r\n//});\r\n",
    "/// <reference path=\"../linker.js\" />\r\n\r\n// A library of generic physics functions.\r\nvar Physics = (function () {\r\n\r\n\r\n    return {\r\n        // TODO: speed up by checking if a does NOT intersect with b (i.e. using OR)\r\n        // Uses simple Speculative Contacts\r\n        isCollision: function (a, b, moe, isLvl) {\r\n            var aX = (typeof (isLvl) !== \"undefined\") ? a.pos.x + a.lvlX : a.pos.x;\r\n\r\n            if ((aX + moe <= (b.pos.x + b.w)) && // a is to the left of the right side of b\r\n\t\t\t\t(b.pos.x + moe <= (aX + a.w)) && // a is to the right of the left side of b\r\n\t\t\t\t(a.pos.y + moe <= (b.pos.y + b.h)) && // a is higher than the bot of b\r\n\t\t\t\t(b.pos.y + moe <= (a.pos.y + a.h)) \t  // a is lower than the top of b\r\n\t\t\t) {\r\n                return true;\r\n            }\r\n\r\n            return false;\r\n        },\r\n        \r\n        // Checks for a collision between two polygons (uses SAT and AABB).\r\n        // @param(GameObj) a A game object.\r\n        // @param(GameObj) b A game object.\r\n        // @param(function) callback A function invoked with SAT.Response ONLY IF a collision occurred.\r\n        isSATcollision: function (a, b, callback) {\r\n            var r = new SAT.Response();\r\n            if (SAT.testPolygonPolygon(a, b, r)) {\r\n                callback(r);\r\n            }\r\n        },\r\n\r\n        // Tests collision between gObj and level.objs[]\r\n        // @param(GameObj) gObj A game object (or subclass).\r\n        // @param(function) callback A callback function.  Called with a SAT.Response().\r\n        testObjObjs: function (gObj, callback) {\r\n            var response = new SAT.Response();\r\n\r\n            for(var i = 0; i < level.objs.length; ++i) {\r\n                var obj = level.objs[i];\r\n\r\n                if (typeof(obj.collidable) === \"undefined\"\r\n                    //&& obj !== gObj         // checks if object is in list (by reference)\r\n                ) {\r\n\r\n                    // Check Level Object Collision\r\n                    var collided = SAT.testPolygonPolygon(gObj, obj, response);\r\n\r\n                    // Respond to Level Object Collision\r\n                    if(collided) {\r\n                        callback(response);\r\n                    }\r\n\r\n                    response.clear();\r\n                }\r\n            }\r\n\r\n            // idea to fix \"hooking\" around edges of platform\r\n            // http://stackoverflow.com/a/1355695/353166\r\n        },\r\n\r\n        // Tests collision between item and level.items[]\r\n        // @param(GameItem) item A game item.\r\n        // @param(function) callback A callback function.  Called with a SAT.Response().\r\n        testItemItems: function (item, callback) {\r\n            var response = new SAT.Response();\r\n\r\n            for (var i = 0; i < level.items.length; ++i) {\r\n                if (!level.items[i].isBeingHeld) {\r\n                        \r\n                    if (level.items[i].type !== JQObject.CRATE)       // TODO: allow non-crates\r\n                        continue;\r\n\r\n                    var collided = SAT.testPolygonPolygon(item, level.items[i], response);\r\n                        \r\n                    if (collided) {\r\n                        if (response.overlapN.y === 1) {   // a is on top of b\r\n                            response.a.pos.x -= response.overlapV.x;\r\n                            response.a.pos.y -= response.overlapV.y;\r\n\r\n                            callback(response);\r\n                            break;\r\n                        }\r\n                    }\r\n\r\n                    response.clear();\r\n                }\r\n            }\r\n        },\r\n\r\n        // Tests collision between hero and the level.items[]\r\n        // @param(function) callback A callback function.  Called with a SAT.Response and the index of the item.\r\n        testHeroItems: function (callback) {\r\n            for (var i = 0; i < level.items.length; ++i) {\r\n                if (level.items[i].visible) {\r\n                    Physics.isSATcollision(hero, level.items[i], function (r) {\r\n                            callback(r, i);\r\n                    });\r\n                }\r\n            }\r\n        },\r\n\r\n\r\n    handleScale: function() {\r\n            var numCratesOnScales = 0;\r\n\r\n            for(var i = 0; i < level.objs.length; ++i) {\r\n                if(level.objs[i].type === JQObject.SCALE &&\r\n                    typeof (level.objs[i].holdingItem) !== \"undefined\" && level.objs[i].holdingItem !== null &&\r\n                    level.objs[i].holdingItem.type === JQObject.CRATE\r\n                ) {\r\n                    ++numCratesOnScales;\r\n                }\r\n            }\r\n\r\n            var doLadder = (numCratesOnScales === 2);\r\n\r\n            if(doLadder) {\r\n                audio.discovery.play();\r\n\r\n                var result = $.grep(level.objs, function(e) {\r\n                    return e.type === JQObject.LADDER;\r\n                });\r\n                result[0].visible = true;\r\n            }\r\n\r\n            return doLadder;\r\n        },\r\n\r\n        // Tests collision between items\r\n        //testAllItems: function () {\r\n        //    var response = new SAT.Response();\r\n\r\n        //    for (var i = 0; i < level.items.length; ++i) {\r\n        //        for (var j = 0; j < level.items.length; ++j) {\r\n        //            if (i !== j && !level.items[i].isBeingHeld && !level.items[j].isBeingHeld) {\r\n                        \r\n        //                if (level.items[i].type !== JQObject.CRATE || level.items[j].type !== JQObject.CRATE)       // TODO: allow non-crates\r\n        //                    continue;\r\n\r\n        //                var collided = SAT.testPolygonPolygon(level.items[i], level.items[j], response);\r\n                        \r\n        //                if (collided) {\r\n        //                    if (response.overlapN.y === 1) {   // a is on top of b\r\n        //                        response.a.pos.x -= response.overlapV.x;\r\n        //                        response.a.pos.y -= response.overlapV.y;\r\n\r\n        //                        response.a.isOnObj = true;\r\n        //                        response.a.onObj = response.b;\r\n        //                        response.b.grabbable = false;\r\n\r\n        //                        level.items.push(response.a);\r\n        //                    }\r\n        //                }\r\n\r\n        //                response.clear();\r\n        //            }\r\n        //        }\r\n        //    }\r\n        //}\r\n    };\r\n})();\r\n",
    "/// <reference path=\"../linker.js\" />\r\n\r\nvar JQObject = Object.freeze({\r\n    EMPTY: 0,\r\n    CRATE: 1,\r\n    LADDER: 2,\r\n    SACK: 3,\r\n    ENEMY: 4,\r\n    CASH: 5,\r\n    DOOR: 6,\r\n    SCALE: 7,\r\n    CLOUD: 8,\r\n    PLATFORM: 9,\r\n    SHURIKEN: 10,\r\n    SLOPE: 11,\r\n    POLY: 12,\r\n    HILL: 13,\r\n    ELEVATOR: 14,\r\n    SCALEBG: 15,\r\n    FIREBALL: 16\r\n});\r\n\r\nvar JQObject_names = Object.freeze({\r\n    0: \"EMPTY\",\r\n    1: \"CRATE\",\r\n    2: \"LADDER\",\r\n    3: \"SACK\",\r\n    4: \"ENEMY\",\r\n    5: \"CASH\",\r\n    6: \"DOOR\",\r\n    7: \"SCALE\",\r\n    8: \"CLOUD\",\r\n    9: \"PLATFORM\",\r\n    10: \"SHURIKEN\",\r\n    11: \"SLOPE\",\r\n    12: \"POLY\",\r\n    13: \"HILL\",\r\n    14: \"ELEVATOR\",\r\n    15: \"SCALEBG\",\r\n    16: \"FIREBALL\"\r\n});\r\n\r\n/*\r\n    GameObj is the base class from which all objects in the game inherit from.\r\n    Every GameObj has a SAT.Vector (pos);       TODO: make Vector not Polygon\r\n    \r\n    @param(JQObject) type The type of the object.\r\n    @param(number) x The x position of the object.\r\n    @param(number) y The y position of the object.\r\n    @param(number?) w The width of the object.\r\n    @param(number?) h The height of the object.\r\n    @param(Image?) src The filename of the object sprite.  unused by default\r\n    @param(Dir) dir The slope direction. TODO: move to own class\r\n\r\n    @constructor\r\n*/\r\nvar GameObj = function (type, x, y, w, h, src, dir) {\r\n    this.dir = dir;\r\n\r\n    // this.pos\r\n    if (type === JQObject.PLATFORM || type === JQObject.ELEVATOR) {\r\n        $.extend(this, Graphics.getSkewedRect(x, y, w, h));\r\n    }\r\n    else if(type === JQObject.SLOPE) {\r\n        $.extend(this, Graphics.getStairPoly(x, y, w, h, dir));\r\n    }\r\n    else if(type === JQObject.HILL) {\r\n        $.extend(this, Graphics.getHill(x, y, w, h));\r\n    }\r\n    else if(type === JQObject.POLY) {\r\n        // custom polygon\r\n    }\r\n    else {\r\n        $.extend(this, new SAT.Box(new SAT.Vector(x, y), w, h).toPolygon());\r\n    }\r\n\r\n    this.type = type;\r\n    this.imgReady = false;     // TODO: make private\r\n\r\n    if (typeof (src) === \"undefined\" || src === null) {\r\n        this.w = w;\r\n        this.h = h;\r\n    }\r\n    else {\r\n        this.w = w; // TODO: fix\r\n        this.h = h;\r\n\r\n        this.img = new Image();\r\n\r\n        var that = this;\r\n        this.img.onload = function () {\r\n            that.imgReady = true;\r\n            that.w = this.width;\r\n            that.h = this.height;\r\n        };\r\n        \r\n        this.img.src = \"img/\" + src;\r\n    }\r\n};\r\n\r\nGameObj.prototype = {\r\n    draw: function () {\r\n        if (this.imgReady) {\r\n            ctx.drawImage(this.img, this.pos.x, this.pos.y);\r\n        }\r\n        else {\r\n            if(this.type === JQObject.SCALEBG) {\r\n                ctx.fillStyle = Color.LIGHT_BROWN;\r\n            }\r\n            else if(this.type === JQObject.FIREBALL) {\r\n                ctx.fillStyle = \"orange\";\r\n            }\r\n            else {\r\n                ctx.fillStyle = \"red\";\r\n            }\r\n\r\n            ctx.fillRect(this.pos.x, this.pos.y, this.w, this.h);\r\n        }\r\n    }\r\n};\r\n",
    "/*\r\n    GameItem extends GameObj\r\n    GameItem may extend SAT.Vector to be SAT.Polygon\r\n\r\n    @param(GameObj) gObj A game object.\r\n    @param(?bool) grabbable Whether the game item can be pickup up or not. (false by default)\r\n    @param(?number) val The value of the game item. (-1 by default)\r\n    @param(?bool) visible Whether the game item is displayed or not.  (true by default)\r\n*/\r\nvar GameItem = function (gObj, grabbable, val, visible) {\r\n    utils.extend(this, gObj);\r\n    \r\n    this.grabbable = (typeof (grabbable) !== \"undefined\") ? grabbable : false;\r\n    this.val = (typeof(val) !== \"undefined\") ? val : -1;\r\n    this.visible = (typeof (visible) !== \"undefined\") ? visible : true;\r\n\r\n    this.vY = 0;\r\n    this.isOnObj = false;   // TODO: allow setting to true to avoid \"thud\" sound on level start\r\n    this.onObj = null;      // contains the object holding up the object (directly below)\r\n\r\n    this.isBeingHeld = false;\r\n\r\n    // TODO: make private/prototype\r\n    var parentDraw = this.draw;\r\n    this.draw = function () {\r\n        if (this.visible) {\r\n            parentDraw.apply(this);\r\n        }\r\n    };\r\n};\r\n\r\n//GameItem.prototype = {\r\n//};\r\n",
    "/// <reference path=\"../linker.js\" />\r\n\r\nvar HUD = (function () {\r\n\r\n    var cash = null,\r\n        medKit = null,\r\n        shuriken = null,\r\n        syringe = null\r\n    ;\r\n\r\n\r\n    function drawHealth(){\r\n        for(var i=0; i < hero.health; ++i){\r\n            ctx.fillStyle = \"red\";\r\n            ctx.fillRect(77 + i*21, FULLH + 8, 19, 8);\r\n        }\r\n    }\r\n\t\r\n    function drawMana(){\r\n        for(var i=0; i < hero.mana; ++i){\r\n            ctx.fillStyle = \"#00b6ff\";\r\n            ctx.fillRect(77 + i*21, FULLH + 26, 19, 8);\r\n        }\r\n    }\r\n\t\r\n    function drawXP() {\r\n        ctx.fillStyle = \"#ddd\";\r\n        ctx.font = \"12px 'Press Start 2P'\";\r\n        \t\r\n        var zero = (hero.xp < 10) ? '0' : '';\r\n        ctx.fillText(zero + hero.xp + '/' + hero.xpNeeded, 77, FULLH + 54);\r\n    }\r\n\r\n\r\n    return {\r\n        init: function () {\r\n            // HUD icons\r\n            cash = new GameObj(JQObject.EMPTY, 548, FULLH + 20, 22, 24, \"cash.png\");\r\n            medKit = new GameObj(JQObject.EMPTY, 238, FULLH + 15, 31, 30, \"medKit.png\");\r\n            shuriken = new GameObj(JQObject.EMPTY, 447, FULLH + 15, 31, 31, \"shuriken.png\");\r\n            syringe = new GameObj(JQObject.EMPTY, 342, FULLH + 18, 25, 25, \"syringe.png\");\r\n        },\r\n\r\n        draw: function () {// TODO: break out static parts\r\n            // background\r\n            ctx.fillStyle = \"#070707\";\r\n            ctx.fillRect(0, FULLH, FULLW, game.padHUD);\r\n\r\n            ctx.fillStyle = \"#ddd\";\r\n            ctx.font = \"11px 'Press Start 2P'\";\r\n\r\n\r\n            ctx.fillText(\"HP-\" + hero.healthLvl, 7, FULLH + 18);\r\n            ctx.fillText(\"MP-\" + hero.manaLvl, 7, FULLH + 37);\r\n            ctx.fillText(\"XP\", 7, FULLH + 54);\r\n            \r\n            drawHealth();\r\n            drawMana();\r\n            drawXP();\r\n\r\n            // hp kit\r\n            ctx.fillText(hero.medKits, 210, FULLH + 37);\r\n            medKit.draw();\r\n\r\n            // mp kit\r\n            ctx.fillText(hero.manaKits, 315, FULLH + 37);\r\n            syringe.draw();\r\n\r\n            // ammo\r\n            ctx.fillText(hero.ammo, 410, FULLH + 37);\r\n            shuriken.draw();\r\n\r\n            // money\r\n            ctx.fillText(hero.cash, 515, FULLH + 37);\r\n            cash.draw();\r\n\r\n            // lives\r\n            ctx.fillText(\"LIVES x\" + hero.lives, 700, FULLH + 37);\r\n\r\n            // time\r\n            var time = utils.getTimeObj(game.actualTime);\r\n            ctx.fillText(time.min + ':' + time.sec, FULLW - 78, FULLH + 24);\r\n        }\r\n    };\r\n})();\r\n",
    "/// <reference path=\"../linker.js\" />\r\n\r\nvar JQEnemy = Object.freeze({\r\n    STILL: 0,\r\n    PATROL: 1,\r\n    FOLLOW: 2\r\n});\r\n\r\n\r\n/*\r\n    Enemy extends GameObj\r\n\r\n    @param(GameObj) gObj A game object (super class).\r\n    @param(EnemyType) enemy_t The type of the enemy.\r\n    @param(number) health The hp of the enemy.\r\n    @param(number) leftXBound The left x coordinate boundary.\r\n    @param(number) rightXBound The right x coordinate boundary.\r\n    @param(bool?) active Is the enemy allowed to move?\r\n    @constructor\r\n*/\r\nvar Enemy = function (gObj, enemy_t, health, leftXBound, rightXBound, active) {\r\n    utils.extend(this, gObj);\r\n\r\n    this.initX = this.pos.x;\r\n    this.initY = this.pos.y;\r\n\r\n    this.initHealth = this.health = health;\r\n    this.enemy_t = enemy_t;\r\n    this.leftXBound = leftXBound;\r\n    this.rightXBound = rightXBound;\r\n    this.active = (typeof (active) !== \"undefined\") ? active : false;\r\n    this.deadOffScreen = false;\r\n\r\n    // TODO: make private (and initHealth)\r\n    this.dir = Dir.RIGHT;\r\n    this.alive = true;\r\n    this.deadOnScreen = false;\r\n    this.clearDir = Dir.RIGHT;\r\n\r\n    \r\n    var that = this;\r\n    \r\n    // draw\r\n    function drawHealth() {\r\n        var healthLen = (that.w / that.initHealth) * that.health;\r\n\r\n        ctx.fillStyle = \"red\";\r\n        ctx.fillRect(that.pos.x, that.pos.y - 12, healthLen, 4);\r\n    }\r\n\r\n    var parentDraw = this.draw;\r\n    this.draw = function () {\r\n        if (this.alive || this.deadOnScreen) {\r\n            if (this.initHealth > 1) {\r\n                drawHealth();\r\n            }\r\n\r\n            ctx.save();\r\n            if (this.deadOnScreen) {\r\n                ctx.globalAlpha = 0.3;\r\n            }\r\n\r\n            parentDraw.apply(this);\r\n            ctx.restore();\r\n        }\r\n    }\r\n};\r\n\r\nEnemy.prototype = {\r\n\r\n    update: function () {\r\n        if (this.deadOnScreen) {\r\n            if(this.enemy_t === JQEnemy.STILL) {\r\n                this.deadOnScreen = false;\r\n                this.deadOffScreen = true;\r\n            }\r\n            else {\r\n                this.pos.x += (this.clearDir === Dir.RIGHT) ? 2 : -2;\r\n                this.pos.y -= 9;\r\n\r\n                if(this.pos.x < 0 || this.pos.x > FULLW) {\r\n                    this.deadOnScreen = false;\r\n                    this.deadOffScreen = true;\r\n                }\r\n            }\r\n        }\r\n        else if (this.active && game.totalTicks % 3 === 0) {\r\n            this.movement();\r\n        }\r\n    },\r\n\r\n    // TODO: make private\r\n    movement: function() {\r\n        if (this.enemy_t === JQEnemy.PATROL) {\r\n            if (this.pos.x + hero.lvlX <= this.leftXBound)\r\n                this.dir = Dir.RIGHT;\r\n            else if (this.pos.x + hero.lvlX >= this.rightXBound)\r\n                this.dir = Dir.LEFT;\r\n\r\n            if (this.dir === Dir.RIGHT) {\r\n                ++this.pos.x;\r\n            }\r\n            else {\r\n                --this.pos.x;\r\n            }\r\n        }\r\n        else if (this.enemy_t === JQEnemy.FOLLOW) {\r\n            if (this.pos.x < hero.pos.x)\r\n                ++this.pos.x;\r\n            else if (this.pos.x > hero.pos.x)\r\n                --this.pos.x;\r\n        }\r\n    },\r\n\r\n    death: function () {\r\n        this.clearDir = hero.dir;\r\n\r\n        audio.enemyDeath.play();\r\n        hero.xp += 15;\r\n        this.alive = false;\r\n        this.deadOnScreen = true;\r\n    },\r\n\r\n    revive: function() {\r\n        this.health = this.initHealth;\r\n        this.deadOffScreen = false;\r\n        this.deadOnScreen = false;\r\n        this.alive = true;\r\n    }\r\n};",
    "/// <reference path=\"../linker.js\" />\r\n\r\nvar level = (function () {\r\n\r\n    var maxVy = 10; // applys to GameObj's and GameItem's\r\n\r\n\r\n    /********** Update **********/\r\n    function updateObjsView() {\r\n        for (var i = 0; i < level.objs.length; ++i) {\r\n            level.objs[i].pos.x -= hero.vX;\r\n\r\n            if(level.objs[i].type === JQObject.SCALEBG) {\r\n                level.objs[i].x2 -= hero.vX;\r\n            }\r\n\r\n        }\r\n    }\r\n\r\n    function updateItemsView() {\r\n        for (var i = 0; i < level.items.length; ++i) {\r\n            level.items[i].pos.x -= hero.vX;\r\n        }\r\n    }\r\n\r\n    function updateBgView() {\r\n        // color layer\r\n        level.bgColor.gradX -= hero.vX;\r\n        level.bgColor.fillStyle = Graphics.getDoorBgGrad();\r\n\r\n        // objects\r\n        for (var i = 0; i < level.bg.length; ++i) {\r\n            var dtX = hero.vX / level.bg[i].speed;\r\n            level.bg[i].pos.x -= dtX;\r\n            level.bg[i].distTraveled += dtX;\r\n        }\r\n    }\r\n\r\n    function updateEnemiesView() {\r\n        for (var i = 0; i < level.enemies.length; ++i) {\r\n            level.enemies[i].pos.x -= hero.vX;\r\n        }\r\n    }\r\n\r\n\r\n    function updateItems() {\r\n        for (var i = 0; i < level.items.length; ++i) {\r\n            if (level.items[i].visible && !level.items[i].isOnObj) {\r\n                // gravity/position\r\n                if (level.items[i].vY < maxVy)\r\n                    level.items[i].vY += game.gravity;\r\n                else\r\n                    level.items[i].vY = maxVy;\r\n\r\n                // obj collision\r\n                Physics.testObjObjs(level.items[i], function(r) {\r\n                    // a is level.items[i]\r\n                    // b is in level.objs\r\n\r\n                    r.a.pos.x -= r.overlapV.x;\r\n                    r.a.pos.y -= r.overlapV.y;\r\n\r\n                    if (r.overlapN.y === 1) {    // on top of platform\r\n                        audio.thud.play();\r\n\r\n                        r.a.vY = (r.b.type === JQObject.ELEVATOR) ? r.b.vY : 0;\r\n                        r.a.isOnObj = true;\r\n                        r.a.onObj = r.b;\r\n                        r.a.recentlyHeld = false;\r\n\r\n                        if(r.b.type === JQObject.SCALE && r.b.holdingItem === null) {\r\n                            r.a.grabbable = false;\r\n                            r.b.holdingItem = r.a;\r\n\r\n                            utils.repeatAction(42, 14, function () {\r\n                                if(r.b.side === Dir.LEFT) {\r\n                                    ++r.a.pos.y;\r\n                                    ++r.b.pos.y;\r\n\r\n                                    ++r.b.hBar.pos.y;\r\n\r\n                                    --r.b.otherSide.pos.y;\r\n                                    --r.b.hBar.y2;\r\n\r\n                                    if(r.b.otherSide.holdingItem !== null) {\r\n                                        --r.b.otherSide.holdingItem.pos.y;\r\n                                        // TODO: chain of crates on top\r\n                                    }\r\n                                }\r\n                                else {\r\n                                    ++r.a.pos.y;\r\n                                    ++r.b.pos.y;\r\n\r\n                                    ++r.b.hBar.y2;\r\n\r\n                                    --r.b.hBar.pos.y;\r\n                                    --r.b.otherSide.pos.y;\r\n\r\n                                    if(r.b.otherSide.holdingItem !== null) {\r\n                                        --r.b.otherSide.holdingItem.pos.y;\r\n                                        // TODO: chain of crates on top\r\n                                    }\r\n                                }\r\n\r\n                            });\r\n                        }\r\n                    }\r\n\r\n                });\r\n\r\n                // item collision\r\n                Physics.testItemItems(level.items[i], function (r) {\r\n                    r.a.isOnObj = true;\r\n                    r.a.onObj = r.b;\r\n                    r.b.grabbable = false;\r\n                    r.a.recentlyHeld = false;\r\n                });\r\n            }\r\n\r\n            if(typeof (level.items[i].onObj) !== \"undefined\" && level.items[i].onObj !== null) {\r\n                level.items[i].vY = (level.items[i].onObj.type === JQObject.ELEVATOR) ? level.items[i].onObj.vY : 0;\r\n            }\r\n\r\n            level.items[i].pos.y += level.items[i].vY;\r\n        }\r\n    }\r\n\r\n    function updateEnemies() {\r\n        for (var i = 0; i < level.enemies.length; ++i) {\r\n            level.enemies[i].update();\r\n\r\n            // TODO: move to hero??\r\n\r\n            if(level.enemies[i].health > 0) {\r\n                // hero and enemy\r\n                if(SAT.testPolygonPolygon(hero, level.enemies[i])) {\r\n                    level.enemies[i].active = true;\r\n\r\n                    if(!hero.invincible) {\r\n                        audio.play(audio.heartbeat, true);\r\n\r\n                        hero.invincible = true;\r\n                        --hero.health;\r\n                    }\r\n                }\r\n\r\n                // projectiles and enemy\r\n                for (var j = 0; j < hero.bulletArr.length; ++j) {\r\n                    if(SAT.testPolygonPolygon(hero.bulletArr[j], level.enemies[i])) {\r\n                        audio.play(audio.thud, true);\r\n                        level.enemies[i].active = true;\r\n\r\n                        hero.bulletArr.splice(j, 1); // remove jth item\r\n                        --level.enemies[i].health;\r\n\r\n                        if (level.enemies[i].health <= 0) {\r\n                            level.enemies[i].death();\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /********** Render **********/\r\n    // the parallax background\r\n    function drawBg() {\r\n        // color background\r\n        ctx.fillStyle = \"#000\";\r\n        ctx.fillRect(0, FULLH - game.padFloor, FULLW, game.padFloor);\r\n        ctx.fillStyle = level.bgColor.fillStyle;\r\n        ctx.fillRect(0, 0, FULLW, FULLH - game.padFloor);\r\n\r\n        // background objects\r\n        for (var i = 0; i < level.bg.length; ++i) {\r\n            //level.bg[i].draw();\r\n            var t = level.bg[i];\r\n            var scale = utils.speed2scale(t.speed);\r\n\r\n            ctx.drawImage(t.img, t.pos.x, t.pos.y, t.w * scale, t.h * scale);\r\n        }\r\n    }\r\n\r\n    // all of the collision rectangles in the level\r\n    function drawObjs() {\r\n        for (var i = 0; i < level.objs.length; ++i) {\r\n            var obj = level.objs[i];\r\n\r\n            // check if visible; TODO: all objs should have visible property (fix api)\r\n            if (typeof (obj.visible) !== \"undefined\" && !obj.visible) {\r\n                continue;\r\n            }\r\n            \r\n\r\n            if(obj.type === JQObject.LADDER) {           // ladder\r\n                Graphics.drawLadder(obj);\r\n            }\r\n            else if(obj.type === JQObject.SCALE) {       // scale\r\n                Graphics.drawScale(obj);\r\n                Graphics.drawPlatformStatus(obj);\r\n            }\r\n            else if(obj.type === JQObject.PLATFORM || obj.type === JQObject.SLOPE || obj.type === JQObject.ELEVATOR) {\r\n                Graphics.drawPlatform(obj);\r\n            }\r\n            else if(obj.type === JQObject.DOOR) {\r\n                Graphics.drawDoor(obj);\r\n            }\r\n            else if(obj.type === JQObject.POLY) {\r\n                Graphics.drawPoly(obj);\r\n            }\r\n            else if(obj.type === JQObject.HILL) {\r\n                Graphics.drawHill(obj);\r\n            }\r\n            else {\r\n                obj.draw();\r\n            }\r\n        }\r\n    }\r\n\r\n    function drawItems() {\r\n        for (var i = 0; i < level.items.length; ++i) {\r\n            level.items[i].draw();\r\n        }\r\n    }\r\n\r\n    function drawEnemies() {\r\n        for (var i = 0; i < level.enemies.length; ++i) {\r\n            if (!level.enemies[i].deadOffScreen) {\r\n                level.enemies[i].draw();\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    return {\r\n        bgColor: {},\r\n        bg: [],             // dynamically holds all of the background objects for the level\r\n        objs: [],           // dynamically holds all of the objects for the level\r\n        items: [],          // dynamically holds all of the items for the level\r\n        enemies: [],        // dynamically holds all of the enemies for the level\r\n        curLvl: null,       // alias for the current level object e.g. lvl1\r\n        isCutscene: false,\r\n        time: 0,\r\n        hiddenItemsFound: 0,\r\n        hiddenItems: 0,\r\n        isTransitioning: false,\r\n        \r\n\r\n        init: function() {\r\n            level.reset();\r\n            level.curLvl = new StartScreen();     // level '0'\r\n        },\r\n\r\n        // called before start of level\r\n        reset: function () {\r\n            // reset game stats\r\n            game.over = false;\r\n            game.actualTime = 0;\r\n\r\n            // reset level\r\n            level.hiddenItemsFound = 0;\r\n            hero.lvlX = 0;\r\n            level.bgColor = {\r\n                fillStyle: \"#000\"\r\n            };\r\n            level.bg = [];\r\n            level.objs = [];\r\n            level.items = [];\r\n            level.enemies = [];\r\n\r\n            // reset hero\r\n            hero.pos.x = 23;\r\n            hero.pos.y = FULLH - game.padFloor - hero.h + 4;    // TODO: find out '4' offset??\r\n            hero.vX = hero.vY = 0;\r\n            hero.isJumping = false;\r\n            hero.ammo = 20;\r\n            hero.bulletArr.length = 0;\t\t// prevents leftover thrown shurikens\r\n            hero.invincible = false;\r\n            hero.isHolding = false;\r\n            hero.curItem = null;\r\n            hero.dir = Dir.RIGHT;\r\n            hero.health = hero.maxHealth;\r\n        },\r\n\r\n        // called at end of level\r\n        complete: function () {\r\n            level.isTransitioning = true;\r\n            audio.lvlComplete();\r\n\r\n            // reset graphics timers (to fix blink text)\r\n            Graphics.ticker = 1;\r\n            Graphics.fadeOut = true;\r\n\r\n            Graphics.fadeCanvas(function () {\r\n                level.isTransitioning = false;\r\n                level.curLvl = lvlComplete;\r\n                level.isCutscene = true;\r\n                level.time = game.actualTime;\r\n\r\n                // TODO: audio.lvlCompleted.play()\r\n            });\r\n        },\r\n\r\n        /******************** Update ********************/\r\n        update: function () {\r\n            if (!level.isTransitioning) {\r\n                if (game.lvl != 0) {\r\n                    updateItems();\r\n                    updateEnemies();\r\n\r\n                    // bg objects\r\n                    var i = level.bg.length;\r\n                    while (i--) {\r\n                        var dtX = 0.5 / level.bg[i].speed;\r\n                        level.bg[i].pos.x -= dtX;\r\n                        level.bg[i].distTraveled += dtX;\r\n\r\n                        if (level.bg[i].distTraveled > level.bg[i].distToTravel) {\r\n                            level.bg.splice(i, 1);\r\n                            Graphics.spawnCloud(level.curLvl.width);\r\n                        }\r\n                    }\r\n                }\r\n\r\n                level.curLvl.update();\r\n            }\r\n        },\r\n\r\n        // fix positions relative to the \"camera\" view\r\n        updateView: function(){\r\n            updateObjsView();\r\n            updateItemsView();\r\n            updateBgView();\r\n            updateEnemiesView();\r\n        },\r\n\r\n\r\n        /******************** Render ********************/\r\n        render: function () {\r\n            drawBg();\r\n            drawObjs();\r\n            drawItems();\r\n            drawEnemies();\r\n            \r\n            level.curLvl.render();\r\n        }\r\n    };\r\n})();\r\n",
    "/// <reference path=\"../linker.js\" />\r\n\r\nvar lvlComplete = (function () {\r\n\r\n    return {\r\n        update: function () {\r\n            if (keysDown[KeyCode.ENTER] || game.lvl === 0 || (window.DEBUG && game.lvl === 1)) {\r\n                lastKeyDown = KeyCode.EMPTY;\r\n\r\n                level.reset();\r\n                \r\n                switch (++game.lvl) {\r\n                    case 1:\r\n                        lvl1.init();\r\n                        level.curLvl = lvl1;\r\n                        break;\r\n                    case 2:\r\n                        lvl2.init();\r\n                        level.curLvl = lvl2;\r\n                        break;\r\n                    case 3:\r\n                        var lvl3 = new Level3();\r\n                        level.curLvl = lvl3;\r\n                }\r\n\r\n                level.isCutscene = false;\r\n            }\r\n        },\r\n\r\n        render: function () {\r\n            // background\r\n            ctx.fillStyle = \"#000\";\r\n            ctx.fillRect(0, 0, FULLW, canvas.height);\r\n\r\n            // title\r\n            ctx.font = \"24px 'Press Start 2P'\";\r\n            var title = \"LEVEL \" + game.lvl + \" COMPLETE\";\r\n            var titleW = ctx.measureText(title).width;\r\n            ctx.fillStyle = Color.ORANGE;\r\n            ctx.fillText(title, HALFW - titleW/2, 70);\r\n            \r\n            // level time\r\n            ctx.font = \"18px 'Press Start 2P'\";\r\n            var time = utils.getTimeObj(level.time);\r\n            var timeTxt = \"LEVEL TIME......\" + time.min + ':' + time.sec;\r\n            var timeW = ctx.measureText(timeTxt).width;\r\n            ctx.fillStyle = \"#e1e1e1\";\r\n            ctx.fillText(timeTxt, HALFW - titleW / 2, 150);\r\n\r\n            // hidden items\r\n            ctx.font = \"18px 'Press Start 2P'\";\r\n            var hdnItems = \"HIDDEN ITEMS.....\" + level.hiddenItemsFound + '/' + level.hiddenItems;\r\n            var hdnItemsW = ctx.measureText(hdnItems).width;\r\n            ctx.fillStyle = \"#e1e1e1\";\r\n            ctx.fillText(hdnItems, HALFW - hdnItemsW / 2, 190);\r\n\r\n            // cta\r\n            Graphics.blinkText(16, HALFW, HALFH + 120);\r\n        }\r\n    };\r\n})();\r\n",
    "/// <reference path=\"../linker.js\" />\r\n\r\n// level '0'\r\nfunction StartScreen() {\r\n    this.width = FULLW;\r\n\r\n    level.isCutscene = true;\r\n}\r\n\r\nStartScreen.prototype = (function() {\r\n    var copyTitle1 = \"JON'S\",\r\n        copyTitle2 = \"QUEST\",\r\n        copyLine = String.fromCharCode(\"169\") + \" 2014 JON WIEDMANN\"\r\n    ;\r\n\r\n    return {\r\n        update: function(){\r\n            if (lastKeyDown === KeyCode.ENTER) {\r\n                level.complete();\r\n            }\r\n        },\r\n\r\n        render: function(){\r\n            //---- title\r\n\r\n            // title 1\r\n            ctx.font = \"29px 'Press Start 2P'\";\r\n            var startX = HALFW - ctx.measureText(copyTitle1).width / 2 + 11,\r\n                startY = 58;\r\n\r\n            ctx.setTransform(1, 0, -0.4, 1.4, 0, 0);\r\n            ctx.fillStyle = \"#222\";\r\n            ctx.fillText('J', startX + 4, startY + 3);\r\n            ctx.fillStyle = \"#ff6a00\";\r\n            ctx.fillText('J', startX, startY);\r\n            ctx.setTransform(1, 0, -0.2, 1.4, 0, 0);\r\n            ctx.fillStyle = \"#222\";\r\n            ctx.fillText('O', startX + 32, startY + 3);\r\n            ctx.fillStyle = \"#ff6a00\";\r\n            ctx.fillText('O', startX + 28, startY);\r\n            ctx.setTransform(1, 0, 0.05, 1.41, 0, -1);\r\n            ctx.fillStyle = \"#222\";\r\n            ctx.fillText('N', startX + 58, startY + 3);\r\n            ctx.fillStyle = \"#ff6a00\";\r\n            ctx.fillText('N', startX + 54, startY);\r\n            ctx.setTransform(1, 0, 0.23, 1.4, 0, 0);\r\n            ctx.fillStyle = \"#222\";\r\n            ctx.fillText(\"'\", startX + 78, startY + 3);\r\n            ctx.fillStyle = \"#ff6a00\";\r\n            ctx.fillText(\"'\", startX + 74, startY);\r\n            ctx.setTransform(1, 0, 0.42, 1.4, 0, 0);\r\n            ctx.fillStyle = \"#222\";\r\n            ctx.fillText('S', startX + 95, startY + 3);\r\n            ctx.fillStyle = \"#ff6a00\";\r\n            ctx.fillText('S', startX + 91, startY);\r\n\r\n\r\n            // title 2\r\n            ctx.font = \"36px 'Press Start 2P'\";\r\n            startX = HALFW - ctx.measureText(copyTitle2).width / 2 + 30;\r\n            startY = 98;\r\n\r\n            ctx.setTransform(1, 0, -0.5, 1.6, 0, 0);\r\n            ctx.fillStyle = \"#222\";\r\n            ctx.fillText('Q', startX + 4, startY + 3);\r\n            ctx.fillStyle = \"#ff6a00\";\r\n            ctx.fillText('Q', startX, startY);\r\n            ctx.setTransform(1, 0, -0.25, 1.6, 0, 0);\r\n            ctx.fillStyle = \"#222\";\r\n            ctx.fillText('U', startX + 26, startY + 3);\r\n            ctx.fillStyle = \"#ff6a00\";\r\n            ctx.fillText('U', startX + 22, startY);\r\n            ctx.setTransform(1, 0, 0.03, 1.6, 0, 0);\r\n            ctx.fillStyle = \"#222\";\r\n            ctx.fillText('E', startX + 50, startY + 3);\r\n            ctx.fillStyle = \"#ff6a00\";\r\n            ctx.fillText('E', startX + 46, startY);\r\n            ctx.setTransform(1, 0, 0.25, 1.6, 0, 0);\r\n            ctx.fillStyle = \"#222\";\r\n            ctx.fillText('S', startX + 74, startY + 3);\r\n            ctx.fillStyle = \"#ff6a00\";\r\n            ctx.fillText('S', startX + 70, startY);\r\n            ctx.setTransform(1, 0, 0.5, 1.6, 0, 0);\r\n            ctx.fillStyle = \"#222\";\r\n            ctx.fillText('T', startX + 90, startY + 4);\r\n            ctx.fillStyle = \"#ff6a00\";\r\n            ctx.fillText('T', startX + 86, startY);\r\n            ctx.setTransform(1, 0, 0, 1, 0, 0);\t// reset\r\n\r\n            //---- press enter\r\n            Graphics.blinkText(22, HALFW, HALFH + 81);\r\n\r\n            //---- copyright\r\n            ctx.fillStyle = \"#000\";\r\n            ctx.fillRect(0, FULLH, FULLW, game.padHUD);\r\n            ctx.font = \"13px 'Press Start 2P'\";\r\n            ctx.fillStyle = \"#c9c9c9\";\r\n\r\n            ctx.fillText(copyLine, HALFW - ctx.measureText(copyLine).width / 2, FULLH + 24);\r\n        }\r\n    };\r\n})();\r\n",
    "/// <reference path=\"../linker.js\" />\r\n\r\nvar lvl1 = (function () {\r\n\r\n    var hiddenCash,\r\n\t\tdoor,\r\n        ladder,\r\n        doLadder = false,\r\n        theScale = {}\r\n    ;\r\n\r\n    function setBackground() {\r\n        // color layer\r\n        level.bgColor.gradX = door.pos.x + door.w/2;\r\n        level.bgColor.gradY = door.pos.y + door.h/2;\r\n\r\n        level.bgColor.fillStyle = Graphics.getDoorBgGrad();\r\n\r\n        // objects\r\n        Graphics.setClouds(lvl1.width);\r\n    }\r\n\r\n    function setObjs() {\r\n        // floor + 3 initial platforms\r\n        level.objs.push(\r\n            new GameObj(JQObject.PLATFORM, -Graphics.projectX, FULLH - game.padFloor - 1, lvl1.width + Graphics.projectX * 2, game.padFloor + 1),\r\n            new GameObj(JQObject.PLATFORM, 200, 206, 267, 62),\r\n            new GameObj(JQObject.PLATFORM, 575, 310, 300, 62),\r\n            new GameObj(JQObject.PLATFORM, 605, 125, 220, 62)\r\n        );\r\n\r\n        // scales\r\n        theScale = Graphics.getScale(1500, FULLH - game.padFloor - 137);\r\n        level.objs.push(theScale.vBar, theScale.hBar, theScale[Dir.LEFT], theScale[Dir.RIGHT]);\r\n\r\n\r\n        // stairs, platform, and door\r\n        var stairs = new GameObj(JQObject.SLOPE, 2203, 208, 252, 62, null, Dir.UP_RIGHT);\r\n        var doorPlat = new GameObj(JQObject.PLATFORM, stairs.pos.x + stairs.w - 11, stairs.pos.y - stairs.h - 5, 200, 62);\r\n        door = new GameObj(JQObject.DOOR, doorPlat.pos.x + doorPlat.w - 63, doorPlat.pos.y - 62 - Graphics.projectY / 2, 33, 62);\r\n        level.objs.push(doorPlat, stairs, door);\r\n\r\n        // TODO: move to setItems() ??\r\n        ladder = new GameItem(new GameObj(JQObject.LADDER, stairs.pos.x - 37, stairs.pos.y - 1, 38, FULLH - stairs.pos.y - game.padFloor), false, 0, false);\r\n        ladder.collidable = false;      // allows ladder to not be in normal collision detection\r\n        level.objs.push(ladder);\r\n    }\r\n\r\n    function setItems() {\r\n        // crates\r\n        var crate = [];\r\n        for (var i = 0; i < 3; ++i) {\r\n            crate.push(\r\n                new GameItem(\r\n                    new GameObj(JQObject.CRATE, 446, FULLH - game.padFloor - 26 + 5, 34, 37, \"crate.png\"),\r\n                    true\r\n                )\r\n            );\r\n        }\r\n        crate[1].pos.x = theScale[Dir.LEFT].pos.x + theScale[Dir.LEFT].w / 2 - crate[0].w / 2;\r\n        crate[2].pos.x = theScale[Dir.RIGHT].pos.x + theScale[Dir.RIGHT].w / 2 - crate[0].w / 2;\r\n\r\n        // sack\r\n        var sack = new GameItem(new GameObj(JQObject.SACK, 680, 111 + Graphics.projectY / 2, 30, 34, \"sack.png\"), false, 5);\r\n\r\n        // hidden cash; TODO: only add to level.items after visible???\r\n        hiddenCash = new GameItem(new GameObj(JQObject.CASH, 113, 80, 22, 24, \"cash.png\"), false, 10, false);\r\n\r\n        level.items.push(crate[0], crate[1], crate[2], sack, hiddenCash);\r\n    }\r\n\r\n    function setEnemies() {\r\n        var cyborg = new Enemy(\r\n            new GameObj(JQObject.ENEMY, 1200, FULLH - game.padFloor - 55 + Graphics.projectY/2, 40, 55, \"cyborgBnW.png\"),\r\n            JQEnemy.FOLLOW,\r\n            1,\r\n            1087,\r\n            1600,\r\n            false\r\n        );\r\n        cyborg.collidable = false;  // TODO: fix api\r\n        level.enemies.push(cyborg);\r\n    }\r\n\r\n\r\n    return {\r\n        width: 2710,\r\n\r\n\r\n        init: function () {\r\n            level.hiddenItems = 1;\r\n\r\n            setObjs();\r\n            setItems();\r\n            setEnemies();\r\n            \r\n            setBackground();\r\n        },\r\n\r\n        deinit: function(){\r\n            hiddenCash = null;\r\n            door = null;\r\n            ladder = null;\r\n            doLadder = false;\r\n        },\r\n\r\n        update: function () {\r\n            // TODO: move to better location\r\n            if (window.DEBUG) {\r\n                level.complete();\r\n            }\r\n\r\n            if(doLadder) {\r\n                hero.onLadder = SAT.testPolygonPolygon(hero, ladder);\r\n            }\r\n            else {\r\n                doLadder = Physics.handleScale();\r\n            }\r\n\r\n            // hidden cash\r\n            if (!hiddenCash.visible) {\r\n                for (var i = 0; i < hero.bulletArr.length; ++i) {\r\n                    if (Physics.isCollision(hero.bulletArr[i], hiddenCash, -17)) {\r\n                        hiddenCash.visible = true;\r\n                        audio.discovery.play();\r\n                        ++level.hiddenItemsFound;\r\n                    }\r\n                }\r\n            }\r\n\r\n            // door\r\n            if (!game.over && Physics.isCollision(hero, door, 0)) {     // TODO: why checking game.over???\r\n                level.complete();\r\n            }\r\n        },\r\n\r\n        render: function() {\r\n            Graphics.drawScaleBg(theScale);\r\n        }\r\n    };\r\n\r\n})();\r\n",
    "/// <reference path=\"../linker.js\" />\r\n\r\nvar lvl2 = (function () {\r\n\r\n    var floor1,\r\n        hill,\r\n        floorPlat,\r\n        colL,\r\n        colR,\r\n        bridge,\r\n        elevator = [],\r\n        wall,\r\n        slope,\r\n        ladder,\r\n        door,\r\n        enemy2hotspot,\r\n        enemy2,\r\n        fireball = null,\r\n        theScale = {},\r\n        doRevive = false,\r\n        doLadder = false\r\n    ;\r\n\r\n\r\n    function setBackground() {\r\n        level.bgColor.gradX = door.pos.x;\r\n        level.bgColor.gradY = door.pos.y;\r\n\r\n        level.bgColor.fillStyle = Graphics.getDoorBgGrad();\r\n        Graphics.setClouds(lvl2.width);\r\n    }\r\n\r\n    function setObjs() {\r\n        floor1 = new GameObj(JQObject.PLATFORM, -Graphics.projectX, FULLH - game.padFloor, FULLW - 250, game.padFloor);\r\n        hill = new GameObj(JQObject.HILL, 200, FULLH - game.padFloor, 320, 60);\r\n        floorPlat = new GameObj(JQObject.PLATFORM, floor1.pos.x + floor1.w - Graphics.projectX, floor1.pos.y - floor1.h - 30, 1000, 180);\r\n        colL = new GameObj(JQObject.PLATFORM, floorPlat.pos.x + 240, floorPlat.pos.y - 90 + Graphics.projectY, 100, 85);\r\n        colR = new GameObj(JQObject.PLATFORM, floorPlat.pos.x + floorPlat.w - 100, floorPlat.pos.y - 90 + Graphics.projectY, 100, 85);\r\n        bridge = new GameObj(JQObject.PLATFORM, colL.pos.x + 140, colL.pos.y - 137, 480, 30);\r\n\r\n        level.objs.push(floorPlat, floor1, hill,colL, colR, bridge);\r\n\r\n        // elevators\r\n        for(var i = 0; i < 3; ++i) {\r\n            elevator[i] = new GameObj(JQObject.ELEVATOR, colR.pos.x + 237 + i * 300, colR.pos.y - i*80, 115, 26);\r\n            elevator[i].dir = Dir.DOWN;\r\n            level.objs.push(elevator[i]);\r\n        }\r\n\r\n        wall = new GameObj(JQObject.PLATFORM, elevator[2].pos.x + elevator[2].w + 120, 190, 100, FULLH - 190);\r\n        slope = new GameObj(JQObject.SLOPE, wall.pos.x + wall.w - Graphics.projectX, wall.pos.y, 900, FULLH - 190, null, Dir.DOWN_RIGHT);\r\n        \r\n        var platty = new GameObj(JQObject.PLATFORM, slope.pos.x + slope.w - Graphics.projectX - 1, FULLH - game.padFloor, 1000, game.padFloor);\r\n\r\n        theScale = Graphics.getScale(platty.pos.x + 250, FULLH - game.padFloor - 137);\r\n        level.objs.push(theScale.hBar, theScale.vBar, theScale[Dir.LEFT], theScale[Dir.RIGHT]);\r\n\r\n        ladder = new GameObj(JQObject.LADDER, platty.pos.x + platty.w - Graphics.projectX - 30, 140, 30, FULLH - 140 - game.padFloor);\r\n        ladder.visible = false;\r\n        ladder.collidable = false;\r\n\r\n        var platty2 = new GameObj(JQObject.PLATFORM, ladder.pos.x + ladder.w, 140, 350, game.padFloor);\r\n\r\n        door = new GameObj(JQObject.DOOR, platty2.pos.x + platty2.w - 90, platty2.pos.y - 100, 40, 100);\r\n\r\n        level.objs.push(platty, slope, wall, platty2, door, ladder);\r\n    }\r\n\r\n    function setItems() {\r\n        var crate = new GameItem(new GameObj(JQObject.CRATE, bridge.pos.x + bridge.w / 2 - 80, bridge.pos.y - 37, 34, 37, \"crate.png\"), true);\r\n        var crate2 = new GameItem(new GameObj(JQObject.CRATE, bridge.pos.x + bridge.w / 2 + 80, bridge.pos.y - 37, 34, 37, \"crate.png\"), true);\r\n                    \r\n        var sack = new GameItem(\r\n            new GameObj(JQObject.SACK, colL.pos.x + 300, 302, 30, 36, \"sack.png\"),\r\n            true,\r\n            5\r\n        );\r\n\r\n        level.items.push(sack, crate, crate2);\r\n    }\r\n\r\n    function setEnemies() {\r\n        var enemy = new Enemy(\r\n            new GameObj(JQObject.ENEMY, colL.pos.x + colL.w, 404, 40, 55, \"cyborgBnW.png\"),\r\n            JQEnemy.PATROL,\r\n            1,\r\n            colL.pos.x + colL.w,\r\n            colR.pos.x - 55/2,\r\n            true\r\n        );\r\n        enemy.collidable = true;        // TODO: fix api\r\n        level.enemies.push(enemy);\r\n\r\n        enemy2 = getEnemy2();\r\n\r\n        enemy2hotspot = new GameObj(JQObject.EMPTY, enemy2.pos.x, enemy2.pos.y, enemy2.w, enemy2.h);\r\n        enemy2hotspot.collidable = false;\r\n        enemy2hotspot.visible = false;\r\n        level.objs.push(enemy2hotspot);\r\n\r\n        level.enemies.push(enemy2);\r\n    }\r\n\r\n    function getEnemy2() {\r\n        en = new Enemy(\r\n            new GameObj(JQObject.ENEMY, wall.pos.x + 35, wall.pos.y - 55, 40, 55, \"cyborgBnW.png\"),\r\n            //new GameObj(JQObject.ENEMY, 135, FULLH - game.padFloor - 55, 40, 55, \"cyborgBnW.png\"),\r\n            JQEnemy.STILL,\r\n            5\r\n        );\r\n        en.collidable = true;\r\n\r\n        return en;\r\n    }\r\n\r\n    function handleFireball() {\r\n        // enemy2hotspot\r\n        if((enemy2hotspot.pos.x + enemy2hotspot.w) >= 0 && (enemy2hotspot.pos.x + enemy2hotspot.w) <= FULLW) {\r\n            // revive enemy2\r\n            if(doRevive) {\r\n                doRevive = false;\r\n                enemy2.revive();\r\n            }\r\n\r\n            // shoot fireball\r\n            if(enemy2.alive && fireball === null) {\r\n                var dir;\r\n                \r\n                if(hero.pos.x < enemy2.pos.x)\r\n                    dir = Dir.LEFT;\r\n                else\r\n                    dir = Dir.RIGHT\r\n\r\n                fireball = new GameObj(JQObject.FIREBALL, enemy2.pos.x, enemy2.pos.y, 20, 20, null, dir);\r\n                fireball.tag = level.objs.length;\r\n                fireball.collidable = false;\r\n                level.objs.push(fireball);\r\n            }\r\n        }\r\n        else if(!enemy2.alive){\r\n            doRevive = true;\r\n        }\r\n\r\n        // update position\r\n        if(fireball !== null) {\r\n            if(fireball.dir === Dir.LEFT) {\r\n                --fireball.pos.x;\r\n            }\r\n            else {\r\n                ++fireball.pos.x;\r\n            }\r\n\r\n            if(fireball.pos.x <= 0 || fireball.pos.x >= FULLW) {\r\n                level.objs.splice(fireball.tag, 1);\r\n                fireball = null;\r\n            }\r\n        }\r\n\r\n        // test collision\r\n        if(!hero.invincible && fireball !== null && SAT.testPolygonPolygon(hero, fireball)) {\r\n            level.objs.splice(fireball.tag, 1);\r\n            fireball = null;\r\n            audio.play(audio.heartbeat, true);\r\n\r\n            hero.invincible = true;\r\n            --hero.health;\r\n        }\r\n    }\r\n\r\n    return {\r\n        width: 5030,\r\n\r\n\r\n        init: function () {\r\n            level.hiddenItems = 0;\r\n\r\n            setObjs();\r\n            setItems();\r\n            setEnemies();\r\n\r\n            setBackground();\r\n        },\r\n\r\n        deinit: function(){\r\n            doLadder = false;\r\n        },\r\n\r\n        update: function() {\r\n            // elevators\r\n            for(var i = 0; i < elevator.length; ++i) {\r\n                if(elevator[i].dir === Dir.UP && elevator[i].pos.y < 100) {\r\n                    elevator[i].dir = Dir.DOWN;\r\n                }\r\n                else if(elevator[i].dir === Dir.DOWN && elevator[i].pos.y > 400) {\r\n                    elevator[i].dir = Dir.UP;\r\n                }\r\n\r\n                elevator[i].vY = (elevator[i].dir === Dir.DOWN) ? 1 : -1;   // used by hero\r\n                elevator[i].pos.y += elevator[i].vY;\r\n            }\r\n            \r\n            // fireball\r\n            handleFireball();\r\n\r\n            // ladder\r\n            if(doLadder) {\r\n                hero.onLadder = SAT.testPolygonPolygon(hero, ladder);\r\n            }\r\n            else {\r\n                doLadder = Physics.handleScale();\r\n            }\r\n\r\n            // door\r\n            if(SAT.testPolygonPolygon(hero, door)) {\r\n                level.complete();\r\n            }\r\n        },\r\n\r\n        render: function() {\r\n            Graphics.drawScaleBg(theScale);\r\n        }\r\n    };\r\n})();",
    "/// <reference path=\"../linker.js\" />\r\n\r\nfunction Level3() {\r\n    this.init();\r\n}\r\n\r\nLevel3.prototype = (function() {\r\n\r\n    function setObjects(){\r\n        var floor = new GameObj(JQObject.FLOOR, -Graphics.projectX, FULLH - game.padFloor, 1000, game.padFloor);\r\n        level.objs.push(floor);\r\n    }\r\n\r\n    return {\r\n        width: 2400,\r\n\r\n\r\n        init: function() {\r\n            level.hiddenItems = 0;\r\n\r\n            setObjects();\r\n            //setItems();\r\n            //setEnemies();\r\n\r\n            //setBackground();\r\n        },\r\n\r\n        deinit: function() {\r\n\r\n        },\r\n\r\n        update: function() {\r\n\r\n        },\r\n\r\n        render: function() {\r\n            ctx.fillStyle = \"#fff\";\r\n            ctx.fillText(\"LEVEL 3 -- COMING SOON\", 300, 300);\r\n            \r\n        }\r\n    };\r\n})();\r\n",
    "/// <reference path=\"../linker.js\" />\r\n\r\nvar game = (function () {\r\n\tvar\tavgFPS = 0,\r\n        renderTimePrev = 0,\r\n        renderTimeBtw = 16,\r\n\t\tfpsHistory = [60],\r\n        updateFpsHistory = [120],\r\n        updateTimePrev = 0,\r\n        updateTimeBtw = 8,\r\n        //lag = 0,\r\n        renderLoop,\r\n        updateLoop\r\n\t;\r\n\t\r\n\tfunction update() {\r\n//\t    var updateTimeCur = new Date().getTime();\r\n\r\n//\t    // timers\r\n//\t    if((updateTimeCur - updateTimePrev) > 0) {\r\n//\t        updateTimeBtw = updateTimeCur - updateTimePrev;\r\n////\t        console.log(updateTimeBtw);\r\n//\t    }\r\n//\t    updateTimePrev = updateTimeCur;\r\n\r\n\r\n\t    if (!level.isCutscene && !level.isTransitioning && !game.over) {\r\n\t        hero.update();\r\n\t    }\r\n\r\n\t\tlevel.update();\r\n\t}\r\n\t\r\n\tfunction render(renderTimeCur) {\r\n        // timers\r\n\t    if ((renderTimeCur - renderTimePrev) > 0) {\r\n\t        renderTimeBtw = renderTimeCur - renderTimePrev;\r\n\t    }\r\n\t    renderTimePrev = renderTimeCur;\r\n\r\n\r\n\t    renderLoop = requestAnimFrame(render);\r\n\r\n        \r\n\t    // drawing\r\n\t    level.render();\r\n\r\n\t    if (!level.isCutscene) {\r\n            if(!game.over)\r\n                hero.render();\r\n\r\n\t        HUD.draw();\r\n\t        drawFPS();\r\n\t    }\r\n\t}\r\n\t\r\n\tfunction drawFPS(fps) {\r\n\t    fpsHistory.push(1000 / renderTimeBtw);\r\n\t    \r\n    \tif (game.totalTicks % 120 === 0) {\r\n    \t    var tot = 0,\r\n                i = fpsHistory.length\r\n    \t    ;\r\n    \t    \r\n    \t    while (--i) {\r\n        \t\ttot += fpsHistory[i];\r\n        \t}\r\n    \t    \r\n    \t    if (fpsHistory.length > 0) {\r\n    \t        avgFPS = Math.floor(tot / fpsHistory.length);\r\n    \t    }\r\n    \t    else {\r\n    \t        avgFPS = 0;\r\n    \t    }\r\n\r\n    \t    while (fpsHistory.length > 0) {\r\n    \t        fpsHistory.pop();\r\n    \t    }\r\n        }\r\n    \t\r\n    \tctx.fillStyle = \"#ddd\";\r\n    \tctx.font = \"11px 'Press Start 2P'\";\r\n\t  \tctx.fillText(avgFPS + \" FPS\", FULLW - 77, FULLH + 50);\r\n\t}\r\n   \t\r\n\r\n\treturn {\r\n        over: false,        // indicates the game is finished\r\n\t    gravity: 0.13,\r\n\t    padHUD: 58,\r\n\t    padFloor: 16,\r\n\t    lvl: 0,\r\n\t    totalTicks: 0,      // ticks are update iterations\r\n\t    actualTime: 0,\r\n\r\n\r\n\t    start: function () {\r\n            // update at fixed time interval\r\n\t        updateLoop = setInterval(function () {\r\n\t            ++game.totalTicks;\r\n\t            Graphics.ticker += Graphics.fadeOut ? -Graphics.tickerStep : Graphics.tickerStep;\r\n\r\n\t            //var updateTimeCur = new Date().getTime();\r\n\r\n\t            //if ((updateTimeCur - updateTimePrev) > 0) {\r\n\t            //game.updateTimeBtw = updateTimeCur - updateTimePrev;\r\n\t            //}\r\n\r\n\t            //updateTimePrev = updateTimeCur;\r\n\t            //lag += game.updateTimeBtw;\r\n\r\n\t            //while (lag >= game.updateTimeBtw) {      // TODO: interpolate if needed\r\n\t            update();\r\n\t            //lag -= game.updateTimeBtw;\r\n\t            //}\r\n\t        }, 8.3333); // 1000 / 120 ==> 2x target rate of 60fps\r\n\t        \r\n            // render w/vsync (let browser decide)\r\n\t        render();\r\n\t    },\r\n\r\n\t    stop: function () {\r\n\t        window.cancelAnimationFrame(renderLoop);\r\n\t        clearInterval(updateLoop);\r\n\t    }\r\n\t};\r\n})();\r\n",
    "/// <reference path=\"../linker.js\" />\r\n\r\nvar Shuriken = {\r\n    w: 31,\r\n    h: 31,\r\n    speed: 4.4\r\n};\r\n\r\n// The hero object.  TODO: convert to be of GameObj type\r\nvar hero = (function () {\r\n    var input = null,           // the hero input component\r\n        graphics = null,        // the hero graphics component\r\n        physics = null,         // the hero physics component\r\n        imgReady = false,\r\n\t\timg = null,\r\n\t\tspriteArr = [],\r\n\t\tinvincibleTimer = 170,\r\n        invincibleTimer0 = 170\r\n\t;\r\n\t\r\n\t\t\r\n\t/*********************** Update ***********************/\r\n    function checkHealth() {\r\n        if (hero.invincible)\r\n            --invincibleTimer;\r\n\r\n        if (invincibleTimer <= 0) {\r\n            hero.invincible = false;\r\n            invincibleTimer = invincibleTimer0;\r\n        }\r\n        \r\n        if (hero.health <= 0 && !game.over) {\r\n            utils.deathSequence();\r\n        }\r\n    }\r\n\r\n    function getSpritePos() {\r\n\t\tvar pos = {x: 0, y: 0};\r\n\t\t\r\n\t\tif (hero.isHolding && hero.vX === 0) {\r\n\t\t\tpos = spriteArr[\"playerDown\"];\r\n\t\t}\r\n\t\telse if (hero.onLadder) {               // TODO: check if holding crate (shouldn't be allowed on ladder)\r\n\t\t    pos = spriteArr[\"playerUp\"];\r\n\t\t}\r\n\t\telse if (hero.dir === Dir.RIGHT || hero.dir === Dir.LEFT) {\r\n\t\t    var dirR = (hero.dir === Dir.RIGHT);\r\n\t\t    var theDir = \"player\" + (dirR ? \"Right\" : \"Left\");\r\n\r\n\t\t    if (dirR && hero.vX > 0 ||  // right\r\n\t\t        !dirR && hero.vX < 0    // left\r\n            ) {\r\n\t\t        var runTimer = (game.totalTicks % 96);\r\n\r\n\t\t        if(!hero.isOnObj){\r\n\t\t            pos = spriteArr[theDir + \"_Run1\"];\r\n\t\t        }\r\n                else if(Math.abs(hero.vX) <= hero.aX*10){\r\n\t\t            pos = spriteArr[theDir + \"_Step\"];\r\n\t\t        }\r\n\t\t        else if(runTimer >= 0 && runTimer < 24) {\r\n\t\t            pos = spriteArr[theDir + \"_Run1\"];\r\n\r\n\t\t            if(!hero.isJumping) {\r\n\t\t                audio.step.play();\r\n\t\t            }\r\n\t\t        }\r\n\t\t        else if (runTimer >= 24 && runTimer < 48) {\r\n\t\t            pos = spriteArr[theDir + \"_Run2\"];\r\n\t\t        }\r\n\t\t        else if(runTimer >= 48 && runTimer < 72){\r\n\t\t            pos = spriteArr[theDir + \"_Run3\"];\r\n\r\n\t\t            if(!hero.isJumping) {\r\n\t\t                audio.step.play();\r\n\t\t            }\r\n\t\t        }\r\n\t\t        else {\r\n\t\t            pos = spriteArr[theDir + \"_Run2\"];\r\n\t\t        }\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t\tpos = spriteArr[theDir];\r\n\t\t}\r\n\t\t\r\n        // idle animation\r\n\t\tif(!hero.onLadder && hero.vX === 0 && hero.vY === 0) {\r\n\t\t    ++hero.idleTime;\r\n\t\t}\r\n\t\telse {\r\n\t\t    hero.idleTime = 0;\r\n\r\n\t\t    if (hero.isHolding) {\r\n\t\t        hero.curItem.pos.y = hero.pos.y + 20;\r\n\t\t    }\r\n\t\t}\r\n\r\n\t\tif (hero.idleTime > 210) {\r\n\t\t    var foo = hero.idleTime % 200;\r\n\t\t    \r\n\t\t    if (foo >= 0 && foo <= 50 || foo > 100 && foo <= 150)\r\n\t\t        pos = spriteArr[\"playerDown\"];\r\n\t\t    else if (foo > 50 && foo <= 100) {\r\n\t\t        pos = spriteArr[\"playerDown_breatheIn\"];\r\n\r\n\t\t        if (hero.isHolding) {\r\n\t\t            hero.curItem.pos.y = hero.pos.y + 18;\r\n\t\t        }\r\n\t\t    }\r\n\t\t    else if (foo > 150 && foo <= 200) {\r\n\t\t        pos = spriteArr[\"playerDown_breatheOut\"];\r\n\r\n\t\t        if (hero.isHolding) {\r\n\t\t            hero.curItem.pos.y = hero.pos.y + 22;\r\n\t\t        }\r\n\t\t    }\r\n\t\t}\r\n\r\n        // invincible\r\n\t\tvar inv = invincibleTimer % 40;\r\n\t\t\r\n\t\tif(hero.invincible && (inv >= 0 && inv <= 16)){\r\n\t\t\tpos = {x: -1, y: -1};\r\n\t\t}\r\n\r\n\t\t\r\n\t\thero.sx = pos.x;\r\n\t\thero.sy = pos.y;\r\n\t}\r\n\t\r\n\t/*********************** Render ***********************/\r\n\tfunction drawHero(){\r\n\t    if (imgReady && hero.sx >= 0 && hero.sy >= 0) {\r\n\t\t    ctx.drawImage(img, hero.sx, hero.sy, hero.w, hero.h, Math.round(hero.pos.x), Math.round(hero.pos.y), hero.w, hero.h);\r\n    \t}\r\n\t}\r\n\t\t\r\n    // used to draw things over the hero\r\n\tfunction drawAfterHero() {\r\n\t    if (hero.isHolding) {\r\n\t        hero.curItem.draw();\r\n\t    }\r\n\t}\r\n\t\t\r\n\treturn {\r\n\t\tsx: 0,\t\t\t\t// sprite position\r\n\t\tsy: 0,\r\n\t\tlvlX: 0,\t\t\t\r\n\t\tw: 48,\r\n\t\th: 65,\r\n\t\tvX: 0,              // maxVx/maxVy are in heroInput.js\r\n\t\tvY: 0,\r\n\t\taX: 0.17,\r\n\t\taY: 0.82,\r\n\t\tjumpMod: 4,\r\n\t\tjumpMod0: 4,\r\n        idleTime: 0,\r\n\t\tdir: Dir.RIGHT,\r\n\t\tonLadder: false,\r\n\t\tinvincible: false,\r\n\t\tisJumping: false,\r\n\t\tisHolding: false,\r\n\t\tisOnObj: true,\r\n\t\tcurItem: null,      // the item in hand\r\n        lives: 3,\r\n\t\thealth: 3,\r\n\t\tmaxHealth: 3,\r\n\t\tmedKits: 1,\r\n\t\thealthLvl: 1,\r\n\t\tmana: 0,\r\n\t\tmaxMana: 4,\r\n\t\tmanaKits: 1,\r\n\t\tmanaLvl: 1,\r\n\t\tammo: 20,\r\n\t\tcash: 0,\r\n\t\tlvl: 1,\r\n\t\txp: 0,\r\n\t\txpNeeded: 50,\r\n\t\tbulletArr: [],\r\n\t\t\r\n\r\n\t\tinit: function(){\r\n\t\t\timg = new Image();\r\n\t\t\timg.onload = function () { imgReady = true; };\r\n\t\t\timg.src = \"img/sprites/player/player.png\";\r\n\t\t\t\r\n\t\t\t// grab texturePacker's sprite coords\r\n\t\t\t$.get(\"img/sprites/player/player.xml\", function(xml){\r\n\t\t\t\tvar wrap = $(xml).find(\"sprite\");\r\n\t\t\t\t\r\n\t\t\t\t$(wrap).each(function(){\r\n\t\t\t\t\tvar name = $(this).attr('n'),\r\n\t\t\t\t\t\tx = $(this).attr('x'),\r\n\t\t\t\t\t\ty = $(this).attr('y');\r\n\t\t\t\t\t\r\n\t\t\t\t\tname = name.substring(0, name.length-4);\r\n\t\t\t\t\tspriteArr[name] = {x: x, y: y};\r\n\t\t\t\t});\r\n\t\t\t\t\r\n\t\t\t});\r\n\t\t\t\r\n\t\t\tinput = HeroInputComponent();\r\n\t\t\tphysics = HeroPhysicsComponent();\r\n\t\t\tgraphics = HeroGraphicsComponent();\r\n\r\n            // setup hero bounding box for collision detection\r\n\t\t\t$.extend(hero, new SAT.Box(new SAT.Vector(0, 0), hero.w, hero.h).toPolygon());\r\n\t\t},\r\n\t\t\r\n\t\tupdate: function () {\r\n\t\t    input.check();                      // updates velocities\r\n\t\t\tphysics.updatePosition();          // updates positions\r\n\t\t\tphysics.checkCollision();          // fix positions\r\n\r\n\t\t\tcheckHealth();\r\n\t\t\tgetSpritePos();\r\n\t\t},\r\n\t\r\n\t\trender: function () {\r\n\t\t    drawHero();\r\n\t\t    graphics.drawBullets();\r\n\t\t    drawAfterHero();\r\n\t\t},\r\n\r\n\t\tlanded: function(y) {\r\n\t\t    hero.isOnObj = true;\r\n\t\t    hero.isJumping = false;\r\n\t\t    hero.vY = 0;\r\n\t\t    hero.pos.y -= y;\r\n\t\t}\r\n\t};\r\n})();\r\n",
    "/// <reference path=\"../linker.js\" />\r\n\r\n/*\r\n    The graphics component of hero.\r\n*/\r\nvar HeroGraphicsComponent = function () {\r\n\r\n    var shurikenReady = false,\r\n        shuriken = new Image()\r\n    ;\r\n\r\n    shuriken.src = \"img/shuriken.png\";\r\n    shuriken.onload = function () {\r\n        shurikenReady = true;\r\n    };\r\n\r\n    return {\r\n        drawBullets: function(){\r\n\t\t    for(var i=0; i < hero.bulletArr.length; ++i){\r\n\t\t        var dirOffset = hero.bulletArr[i].dirR ?\r\n    \t\t\t\t\t\t\t    hero.w : \r\n    \t\t\t\t\t\t\t    0;\r\n\t            \r\n\t\t        hero.bulletArr[i].deg += 5;\r\n            \r\n\t\t        if (shurikenReady) {\r\n\t\t            Graphics.drawRotate(\r\n                        shuriken,\r\n                        hero.bulletArr[i].pos.x + dirOffset,\r\n                        hero.bulletArr[i].pos.y + 20,\r\n                        hero.bulletArr[i].deg\r\n                    );\r\n\t\t        }\r\n\t\t    }\r\n        }\r\n    };\r\n};\r\n",
    "/// <reference path=\"../linker.js\" />\r\n\r\n// The physics component of hero.\r\nvar HeroPhysicsComponent = function () {\r\n\r\n    /*\r\n        Updates projectiles position.\r\n\r\n        Tests for projectile collision against screen.\r\n        Tests for projectile collision against objects.\r\n    */\r\n    function projectileHandler() {\r\n        for (var i = 0; i < hero.bulletArr.length; ++i) {\r\n            hero.bulletArr[i].pos.x += hero.bulletArr[i].dirR ? Shuriken.speed : -Shuriken.speed;   // update position\r\n\r\n            if (hero.bulletArr[i].pos.x > FULLW || hero.bulletArr[i].pos.x < 0) {\t\t    // projectile and screen\r\n                hero.bulletArr.splice(i, 1); // remove ith item\r\n            }\r\n            else {\r\n                Physics.testObjObjs(hero.bulletArr[i], function(){                  // projectile and objects\r\n                    hero.bulletArr.splice(i, 1);\r\n                });\r\n            }\r\n        }\r\n    }\r\n\r\n    function screenCollision() {\r\n        if (hero.pos.y < -hero.h*2) {                 // feet 2x above top of screen\r\n            hero.pos.y = -hero.h*2;\r\n            hero.vY = 0;\r\n        }\r\n        else if (hero.pos.y >= FULLH + hero.h*2) {  // 2x below bottom of screen\r\n            if (!game.over) {\r\n                utils.deathSequence();\r\n            }\r\n        }\r\n\r\n        if (hero.pos.x < 0) { \t\t\t\t\t\t// left\r\n            hero.pos.x = 0;\r\n            hero.vX = 0;\r\n        }\r\n        else if (hero.pos.x > (FULLW - hero.w)) { \t// right \r\n            hero.pos.x = FULLW - hero.w;\r\n            hero.vX = 0;\r\n        }\r\n    }\r\n\r\n    function levelCollision() {\r\n        hero.isOnObj = false;   // prevents jumping after walking off platform\r\n\r\n        Physics.testObjObjs(hero, function(r) {\r\n            // alias the collision direction\r\n            var dir = {\r\n                x: Dir.NONE,\r\n                y: Dir.NONE\r\n            };\r\n\r\n            if(r.overlapN.y === 1)\r\n                dir.y = Dir.TOP;\r\n            else if(r.overlapN.y === -1)\r\n                dir.y = Dir.BOT;\r\n\r\n            if(r.overlapN.x === 1)\r\n                dir.x = Dir.LEFT;\r\n            else if(r.overlapN.y === -1)\r\n                dir.x = Dir.RIGHT;\r\n\r\n\r\n            // check object type\r\n            if(r.b.type === JQObject.SLOPE || r.b.type === JQObject.POLY || r.b.type === JQObject.HILL) {\r\n                //r.a.pos.x -= r.overlapV.x;\r\n\r\n                if(hero.vY >= 0) { // prevents hooking on edge\r\n                    hero.landed(r.overlapV.y);\r\n                }\r\n            }\r\n            else if(r.b.type === JQObject.ELEVATOR) {\r\n                if(dir.y === Dir.TOP && hero.vY >= 0) {\r\n                    hero.isOnObj = true;\r\n                    hero.isJumping = false;\r\n                    hero.vY = (r.b.vY > 0) ? r.b.vY : 0;\r\n\r\n                    r.a.pos.y -= r.overlapV.y;\r\n                }\r\n            }\r\n            else {\r\n                r.a.pos.x -= r.overlapV.x;\r\n\r\n                if(dir.y === Dir.TOP && hero.vY >= 0) {  // prevents hooking on edge\r\n                    hero.landed(r.overlapV.y);\r\n                }\r\n                else if(dir.y === Dir.BOT && hero.vY <= 0) {  // prevents hooking on edge\r\n                    hero.vY = 0;\r\n                    r.a.pos.y -= r.overlapV.y;\r\n                }\r\n            }\r\n        });\r\n        \r\n        if (hero.isHolding) {\r\n            if (hero.vX === 0) {\r\n                hero.curItem.pos.x = hero.pos.x + 7;\r\n                hero.curItem.pos.y = hero.pos.y + 20;\r\n            }\r\n            else {\r\n                hero.curItem.pos.x = hero.pos.x + ((hero.dir === Dir.RIGHT) ? 45 : -32);\r\n                hero.curItem.pos.y = hero.pos.y + 16;\r\n            }\r\n        }\r\n\r\n        Physics.testHeroItems(function (r, idx) {\r\n            if (r.b.type === JQObject.CRATE) {      // TODO: make more generic\r\n                if (r.overlapN.y === 1) {           // on top\r\n                    hero.pos.y -= r.overlapV.y;\r\n                    hero.isOnObj = true;\r\n                    hero.isJumping = false;\r\n\r\n                    hero.vY = 0;\r\n\r\n                    if(typeof (r.b.onObj) !== \"undefined\" && r.b.onObj !== null) {  // hero on crate on elevator\r\n                        if(r.b.onObj.type === JQObject.ELEVATOR) {\r\n                            hero.vY = r.b.vY;\r\n                        }\r\n                    }\r\n                }\r\n                else if (!hero.isHolding && r.b.grabbable && !r.b.recentlyHeld) {\r\n                    if (r.b.isOnObj === true) {\r\n                        r.b.isOnObj = false;\r\n\r\n                        if (r.b.onObj !== null) {\r\n                            r.b.onObj.grabbable = true;\r\n                            r.b.onObj = null;\r\n                        }\r\n                    }\r\n\r\n                    r.b.isBeingHeld = true;\r\n\r\n                    hero.curItem = r.b;\r\n                    hero.isHolding = true;\r\n\r\n                    level.items.splice(idx, 1);\r\n                }\r\n            }\r\n            else {\r\n                audio.itemPickedUp.play();\r\n\r\n                if (r.b.type === JQObject.SACK) {\r\n                    hero.ammo += r.b.val;\r\n                }\r\n                else if (r.b.type === JQObject.CASH) {\r\n                    hero.cash += r.b.val;\r\n                }\r\n\r\n                level.items.splice(idx, 1);\r\n            }\r\n        });\r\n    }\r\n\r\n    return {\r\n        updatePosition: function (){\t\r\n            // TODO: buggy at edges, quickly changing direction incorrectly causes an updateView()\r\n            \r\n            if(((hero.dir === Dir.RIGHT && hero.pos.x >= (HALFW + 35)) ||\r\n               (hero.dir === Dir.LEFT && hero.pos.x <= (HALFW - 45))) &&\r\n               (hero.lvlX + hero.vX >= 0) &&\r\n               (hero.lvlX + hero.vX <= level.curLvl.width - FULLW)\r\n            ){\r\n                hero.lvlX += hero.vX;\r\n\r\n                // updateProjectileView\r\n                for(var i = 0; i < hero.bulletArr.length; ++i) {\r\n                    hero.bulletArr[i].pos.x -= hero.vX;\r\n                }\r\n\r\n                level.updateView();\r\n            }\r\n            else {\r\n                hero.pos.x += hero.vX;\r\n            }\r\n\r\n            if (!hero.onLadder) {\r\n                hero.pos.y += hero.vY;\r\n            }\r\n        },\r\n\r\n        checkCollision: function () {\r\n            projectileHandler();\r\n            screenCollision();\t    // hero and screen\r\n            levelCollision();\r\n        }\r\n    };\r\n};\r\n",
    "/// <reference path=\"../linker.js\" />\r\n\r\nvar KeyCode = Object.freeze({\r\n    ENTER: 13,\r\n    CTRL: 17,\r\n    A: 65,\r\n    D: 68,\r\n    F: 70,\r\n    H: 72,\r\n    J: 74,\r\n    K: 75,\r\n    M: 77,\r\n    O: 79,\r\n    R: 82,\r\n    S: 83,\r\n    W: 87,\r\n    EMPTY: -1,\r\n    SPACEBAR: 32\r\n});\r\n\r\n// The input component of hero.\r\nvar HeroInputComponent = function () {\r\n\r\n    var maxVx = 3,\r\n        maxVy = 10\r\n    ;\r\n\r\n    // global key vars\r\n    keysDown = {};\r\n    lastKeyDown = -1;\r\n\r\n    $(document).on(\"click\", \".resize\", function () {\r\n        if ($(this).hasClass(\"off\")) {\r\n            $(this).removeClass(\"off\").addClass(\"on\");\r\n            $(this).children(\"span\").removeClass(\"icon-expand\").addClass(\"icon-contract\");\r\n        }\r\n        else if ($(this).hasClass(\"on\")) {\r\n            $(this).removeClass(\"on\").addClass(\"off\");\r\n            $(this).children(\"span\").removeClass(\"icon-contract\").addClass(\"icon-expand\");\r\n        }\r\n\r\n        utils.toggleFullScreen();\r\n    });\r\n\r\n    addEventListener(\"keydown\", function (e) {\r\n        if (e.keyCode === KeyCode.SPACEBAR)\r\n            e.preventDefault(); \t\t\t    // scrolling to bottom of page\r\n        else if (e.keyCode === KeyCode.M)\t    // mute/unmute\r\n            audio.handleMuteButton();\r\n        else if (e.keyCode === KeyCode.F)        // resize\r\n            $(\".resize\").trigger(\"click\");\r\n        else if (e.keyCode === KeyCode.K &&\t\t// jump; TODO: move to check() function\r\n               (!hero.isJumping && ((lastKeyDown !== KeyCode.K) || !(keysDown[KeyCode.K]))) &&\r\n               hero.isOnObj\r\n        ) {\r\n            audio.jump.play();\r\n            hero.vY = 0;\r\n            hero.isJumping = true;\r\n            hero.isOnObj = false;\r\n        }\r\n        else if (e.keyCode === KeyCode.J &&\t\t// shoot; TODO: move to check() function\r\n                ((lastKeyDown != KeyCode.J) || !(keysDown[KeyCode.J]))\r\n        ) {\r\n            if (hero.ammo > 0 && !hero.isHolding) {\r\n                audio.play(audio.effort);\r\n\r\n                var projectile = new GameObj(JQObject.SHURIKEN, hero.pos.x, hero.pos.y + Shuriken.h/2, Shuriken.w, Shuriken.h);\r\n                projectile.dirR = (hero.dir === Dir.RIGHT);\r\n                projectile.deg = 0;\r\n\r\n                hero.bulletArr.push(projectile);\r\n\r\n                --hero.ammo;\r\n                hero.idleTime = 0;\r\n            }\r\n        }\r\n        else if (e.keyCode == KeyCode.O) {      // options\r\n            utils.toggleMenu();\r\n        }\r\n\r\n        lastKeyDown = e.keyCode;\r\n        keysDown[e.keyCode] = true;\r\n    }, false);\r\n\r\n    addEventListener(\"keyup\", function (e) {\r\n        delete keysDown[e.keyCode];\r\n    }, false);\r\n\r\n\r\n    return {\r\n        check: function () {\r\n            var doGravity = false;\r\n\r\n            // jumping\r\n            if (hero.isJumping) {\r\n                if (hero.jumpMod > 0) {\r\n                    hero.vY -= hero.aY * hero.jumpMod--;\r\n                }\r\n                else {\r\n                    doGravity = true;\r\n                }\r\n            }\r\n            else {\r\n                hero.jumpMod = hero.jumpMod0;\r\n                doGravity = true;\r\n            }\r\n\r\n            if (doGravity && !hero.onLadder) {\r\n                var fixVy = hero.vY + game.gravity*2;\r\n\r\n                if (fixVy > maxVy) {\r\n                    hero.vY = maxVy;\r\n                }\r\n                else {\r\n                    hero.vY = fixVy;\r\n                }\r\n            }\r\n\r\n\r\n            // --------- keys pressed --------\r\n            var leftOrRight = false;\r\n            // left\r\n            if(keysDown[KeyCode.A]){\r\n                hero.vX = (Math.abs(hero.vX - hero.aX) > maxVx) ? -maxVx : (hero.vX - hero.aX);\r\n                hero.dir = Dir.LEFT;\r\n                leftOrRight = true;\r\n            }\r\n\r\n            // right\r\n            if (keysDown[KeyCode.D]) {\r\n                hero.vX = (Math.abs(hero.vX + hero.aX) > maxVx) ? maxVx : (hero.vX + hero.aX);\r\n                hero.dir = Dir.RIGHT;\r\n                leftOrRight = true;\r\n            }\r\n\t    \r\n            if(Math.abs(hero.vX) < hero.aX){    \r\n                hero.vX = 0;\r\n            }\r\n            else if(!leftOrRight){\r\n                //hero.vX += (hero.vX > 0) ? -game.friction : game.friction;\r\n                hero.vX /= 1.26;\r\n            }\r\n\t    \r\n\r\n            // up\r\n            if (keysDown[KeyCode.W]) {\r\n                if (hero.onLadder) {\r\n                    --hero.pos.y;\r\n                }\r\n            }\r\n\r\n            // down\r\n            if (keysDown[KeyCode.S]) {\r\n                if (hero.onLadder) {\r\n                    ++hero.pos.y;\r\n                }\r\n            }\r\n\r\n\t    \r\n            // drop \r\n            if (keysDown[KeyCode.SPACEBAR]) {\r\n                if (hero.isHolding) {\r\n                    hero.isHolding = false;\r\n                    hero.curItem.isBeingHeld = false;\r\n                    hero.curItem.recentlyHeld = true;       // TODO: fix api\r\n                    level.items.push(hero.curItem);\r\n                    hero.curItem = null;\r\n                }\r\n            }\r\n\r\n\t\t\r\n            //----- heal (h)\r\n            if(keysDown[KeyCode.H]){\r\n                if(hero.medKits > 0 && hero.health < hero.maxHealth){\r\n                    ++hero.health;\r\n                    --hero.medKits;\r\n\r\n                    audio.play(audio.enchant, true);\r\n                }\r\n            }\r\n\t\t\r\n\t\t\r\n            // restore\r\n            if(keysDown[KeyCode.R] && !(keysDown[KeyCode.CTRL])){\r\n                if(hero.manaKits > 0 && hero.mana < hero.maxMana){\r\n                    ++hero.mana;\r\n                    --hero.manaKits;\r\n\r\n                    audio.play(audio.enchant, true);\r\n                }\r\n            }\r\n\t\t\r\n        }\r\n    };\r\n};\r\n",
    "/// <reference path=\"linker.js\" />\r\n\r\nvar Main = (function () {\r\n\r\n    function setCanvasGlobals() {\r\n        canvas = $(\"canvas\")[0];\r\n        ctx = canvas.getContext(\"2d\");\r\n        \r\n        FULLW = canvas.width;\r\n        FULLH = canvas.height - game.padHUD;\r\n        HALFW = FULLW / 2;\r\n        HALFH = FULLH / 2;\r\n    }\r\n\r\n    function loadingScreen() {\r\n        ctx.fillStyle = \"#e1e1e1\";\r\n        ctx.font = \"25px 'Press Start 2P'\";\r\n        ctx.fillText(\"LOADING...\", HALFW - 80, HALFH + 20);\r\n    }\r\n\r\n    function debug() {\r\n        // dev enviroment\r\n        if (location.host === \"jon\") {\r\n            window.DEBUG = true;\r\n\r\n            // speed up canvas transition\r\n            $(canvas).css({\"transition\": \"opacity 0.01s\"});\r\n\r\n            // skip start screen\r\n            lastKeyDown = KeyCode.ENTER;\r\n\r\n            // mute audio\r\n            audio.handleMuteButton();\r\n        }\r\n    }\r\n\r\n\r\n    return {\r\n        init: function () {\r\n            setCanvasGlobals();\r\n            loadingScreen();\r\n\r\n            hero.init();\r\n            audio.init();\r\n            level.init();\r\n            HUD.init();\r\n\r\n            // wait for google font\r\n            $(document).on(\"fontLoaded\", function () {\r\n                // game timer\r\n                setInterval(function () {\r\n                    ++game.actualTime;\r\n                }, 1000);\r\n\r\n                // start the game\r\n                game.start();\r\n\r\n\r\n                //debug();\r\n            });\r\n        }\r\n    }\r\n})();\r\n\r\n$(function () {\r\n    // load font\r\n    window.WebFontConfig = {\r\n        google: {\r\n            families: ['Press Start 2P']\r\n        },\r\n        active: function () {\r\n            $(document).trigger(\"fontLoaded\");\r\n        },\r\n        inactive: function () {\r\n            alert(\"There was a problem loading a font from google, some text may not render correctly (refreshing the page may fix the issue).\");\r\n            $(document).trigger(\"fontLoaded\");\r\n        }\r\n    };\r\n\r\n    (function () {\r\n        var wf = document.createElement(\"script\");\r\n        wf.src = \"//ajax.googleapis.com/ajax/libs/webfont/1/webfont.js\";\r\n        wf.type = \"text/javascript\";\r\n        wf.async = \"true\";\r\n        var s = document.getElementsByTagName(\"script\")[0];\r\n        s.parentNode.insertBefore(wf, s);\r\n    })();\r\n\r\n\r\n    Main.init();\r\n});\r\n"
  ]
}